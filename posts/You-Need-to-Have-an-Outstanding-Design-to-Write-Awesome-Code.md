<h4><strong><em>If you design it right, it will last&#xA0;forever.</em></strong></h4><figure><img alt src="https://hackernoon.com/hn-images/1*HrpjCEowOzDtO6mTnCfuJg.jpeg"></figure><p>Broadly speaking there can be six phases in every&#xA0;project</p><p>&#xB7; Enthusiasm</p><p>&#xB7; Disillusionment</p><p>&#xB7; Panic</p><p>&#xB7; <strong>Search for the root&#xA0;cause</strong></p><p>&#xB7; Punishment of the&#xA0;innocent</p><p>&#xB7; Praise and honors for the non-participants</p><p>The &#x201C;<strong>search for the root cause</strong>&#x201D; phase is very tiring and demanding especially when a project is doomed to fail. Here, we look back on projects gone horribly wrong and ask ourselves, &#x201C;<strong>What happened</strong>?&#x201D; We do a post-mortem and try to put together the broken pieces that will explain how we&#xA0;failed.</p><p>And then we come up with valid reasons&#xA0;like.</p><p>&#xB7; Poor requirements (<em>Client does not know what he wants!!!)</em></p><p>&#xB7; Poor Planning (<em>our project manager screwed it&#xA0;up!!!)</em></p><p>&#xB7; Poor Management (<em>Wish the CEO had shown more balls!!!)</em></p><p>And the reasons go&#xA0;on&#x2026;&#x2026;.</p><p>Finally, we toss up a nice PPT, give <strong>&#x201C;big assurances&#x201D;</strong> for future projects, <strong>&#x201C;shuffle&#x201D;</strong> two or three resources out of the project and then majestically close that one painfully long fucking project to everybody&#x2019;s <strong>&#x201C;satisfaction.&#x201D;</strong></p><p>But in the whole process of cover-up, we conveniently ignore the single most important factor that resulted in&#xA0;failure</p><blockquote><strong>Managing Complexity.</strong></blockquote><p>The software became so complex that it reached a stage where no one knew what it does. When any project reaches a point where no one completely understands how the impact of code changes in one area will impact any other area, we can rest assured that the project is doomed to failure. Sooner or later the project comes to a grinding&#xA0;halt.</p><blockquote><strong>And a complex project gets created due to a stinking&#xA0;design.</strong></blockquote><p>As Irene Au has rightly&#xA0;said.</p><blockquote><strong><em>&#x201C;Good design is like a refrigerator&#x200A;&#x2014;&#x200A;when it works, no one notices, but when it doesn&#x2019;t, it sure&#xA0;stinks.&#x201D;</em></strong></blockquote><p>And here are some of the wonderful design principles that helped me throughout my programming career.</p><h3>Create Consistent Abstractions</h3><p>Josef Albers rightly&#xA0;said.</p><blockquote><strong><em>&#x201C;Abstraction is real, probably more real than nature.&#xA0;&#x201C;</em></strong></blockquote><p>Abstraction is the ability to engage with a concept while safely ignoring the finer details existing at different levels. We find and use abstraction everywhere in the real world. For example, when we refer to any object as a <strong>car</strong>, we automatically refer to it as a whole rather than breaking it into its individual parts like chassis, engine, brakes&#xA0;etc.</p><p>In software terms, the need of the hour is to create powerful base classes that allow you to focus on a set of common attributes of a set of derived classes while ignoring the details of specific&#xA0;classes.</p><p>Thus a good class interface is an abstraction that allows you to focus on the interface without worrying about the inner workings of the class. This creates a design which is simple and then easily decoupled.</p><p>A great software design means abstractions created at the routine-interface level, class-interface level and package-interface level and this results in faster and safer programming.</p><h3>Hide the Implementation Details</h3><p>Len Wein hits the nail on the head when he&#xA0;says.</p><blockquote><strong><em>&#x201C;In general, shorter is better. If you can encapsulate your idea into a single captivating sentence, you&#x2019;re halfway&#xA0;home.&#x201D;</em></strong></blockquote><p>Hiding or encapsulating picks up where abstraction leaves. While abstraction <strong>says &#x201C;You are allowed to look at any object at a higher level of detail&#x201D;</strong>, encapsulations goes one step further and says <strong>&#x201C;You are not allowed to look at that object with any other level of detail&#xA0;also.&#x201D;</strong></p><p>This is where the wonderful concept of <strong>inheritance</strong> comes&#xA0;in.</p><p>In designing any software system, we can often find that objects are very similar to each other except for some differences. For example, while designing a contracting system, we can have different types of contracts (fixed, time and material, incentive-based etc.), but the general attributes of each contract remain the same. Thus you can create a generic object called <strong>&#x201C;contract&#x201D;</strong> and then define <strong>&#x201C;fixed price&#x201D;</strong> contract as <strong>&#x201C;inherited&#x201D;</strong> from <strong>contract</strong> object with some additional attributes and so&#xA0;on.</p><p>Inheritance simplifies the design because you write a generic routine to handle anything and then write specific routines to take care of specific scenarios. Not only is the code &#x201C;<strong>clean</strong>&#x201D; but it also offers a great way to decouple unnecessary details from the developer who will be using the class or object for inheriting.</p><p><strong>Inheritance is one of object-oriented programming&#x2019;s most powerful tools. It is a double-edged sword; it can provide great benefits when used correctly and it can do great damage when used&#xA0;naively.</strong></p><h3>Change will Happen. Plan for&#xA0;it.</h3><p>Amit Ray kills it beautifully when he&#xA0;says.</p><blockquote><strong><em>&#x201C;In every change, in every falling leaf there is some pain, some beauty. And that&#x2019;s the way new leaves&#xA0;grow.&#x201D;</em></strong></blockquote><p>While designing any system, changes anticipated need to keep in account and provisions should be kept in place to prevent any heartburns and grieving&#x2019;s later. As a rule of thumb, you need to design your system such that the effect or scope of the change is directly proportional to the probability of the same happening.</p><p><strong>The more the probability, the more the system needs to be ready to accommodate the&#xA0;change.</strong></p><p>A good starting point can be to identify the areas which have the potential to change and then identify the bare minimal subset which is expected to remain constant. All subsequent planning can be done on top of this minimal&#xA0;subset.</p><p>Thus by identifying the core first, you can clearly see which add-on components need to be built and accordingly leave &#x201C;<strong>exits</strong>&#x201D; in the code to plan for the implementation at a later point in&#xA0;time.</p><p>Thus, in a nutshell, create a set of classes and routines with small, direct and flexible relations with core classes in a &#x201C;<strong>loosely coupled</strong> &#x201C;way. This loose coupling enables the design to be flexible enough to accommodate changes and make way for easy implementation.</p><h3>Iterate until you get it&#xA0;right.</h3><p>Sebastian Thrun rightly&#xA0;said.</p><blockquote><strong>&#x201C;Few ideas work on the first try. Iteration is key to innovation&#x201D;.</strong></blockquote><p>Design is always an iterative process. You would often find that you go from point A to point B and then again come back to point A to start all over again. It is frustrating but there are no shortcuts to arriving at a robust workable design. Patience is the&#xA0;key.</p><p>As you walk along the path from A to B, you will see various designs, try various approaches and envisage various high and low-level views. The initial high-level view is fluid and as you walk along, you solidify the same into concrete low-level views. Finally, you decide on an approach; top-down or bottom-up and then create a framework based on&#xA0;that.</p><p>The key is not stopping at the first attempt. The second attempt is always better than the first and you learn things on each attempt which improves the overall design progressively. Incremental refining is a very powerful tool to reduce complexity.</p><blockquote>As Polya has rightly said.<br> <strong>&#x201C;Understand the problem, devise a plan, carry out the plan and then look back to see how you&#xA0;did.&#x201D;</strong></blockquote><h3>Prototyping is the proof in the&#xA0;pudding</h3><p>Laurie Anderson correctly has&#xA0;said.</p><blockquote><strong><em>&#x201C;The problem with prototypes is they don&#x2019;t always work. But that is how it is meant to&#xA0;be&#x201D;</em></strong></blockquote><p>Perhaps the biggest advantage of prototyping is the visual representation of design, a picture even if on a smaller scale is more than a thousand words. This picture not only convinces us of the workability of the design but also helps in getting the necessary &#x201C;<strong>buy-ins</strong>&#x201D; and approvals to move&#xA0;ahead.</p><p>But having said that, Prototyping isn&#x2019;t for every project, but for the projects, it is right for, it can be a tremendous asset.</p><p>The Prototyping Model is a system development method (SDM) in which a prototype (an early draft of a final system or product) is built, tested and then reworked as necessary until an acceptable prototype is eventually achieved from which the complete system or product can be developed.</p><p>A prototype serves as a throwaway model made to understand the requirements of a project before design and coding begins. In essence, prototyping is a project test&#xA0;run.</p><p>There are many unexpected problems that can occur during the software development process, even if you have revised the design several times. Prototyping test will at least let the development team knows where are the problems and have the opportunity to improve it before released the product&#xA0;public.</p><p>Used with discipline, prototyping is the workhorse tool, a designer has at his disposal to combat design wickedness. <strong>The payback can be immense; just look at the&#xA0;iPhone.</strong></p><h3>So How much is enough&#xA0;design</h3><p>Unfortunately, there is no rational or logical answer to this question. In most of the cases, it is more of a judgment call than anything else. But while you cannot guarantee with precision the right amount of design required in any project; two design approaches are bound to fail every&#xA0;time.</p><p>&#xB7; Having no design at&#xA0;all</p><p>&#xB7; Designing everything upfront till the last&#xA0;detail.</p><p>Strive for simplicity and dogmatically persist with iteration until you arrive at the most optimal design. <strong>The more your design is closer to the real-life problem, it is designed to solve, the more are its chances of success, as simple as&#xA0;that.</strong></p><p>As Steve jobs has aptly&#xA0;said.</p><blockquote><strong>&#x201C;Design is not just what it looks like and feels like. Design is how it&#xA0;works.&#x201D;</strong></blockquote><blockquote>About the&#xA0;author-:</blockquote><blockquote><strong>Ravi Rajan is a global IT program manager based out of Mumbai, India. He is also an avid blogger, Haiku poetry writer, archaeology enthusiast and history maniac. Connect with Ravi on </strong><a href="https://in.linkedin.com/in/ravishankarrajan"><strong>LinkedIn</strong></a><strong>, </strong><a href="https://medium.com/@rsrajan1"><strong>Medium</strong></a><strong> and&#xA0;</strong><a href="http://www.twitter.com/rsrajan1"><strong>Twitter</strong></a><strong>.</strong></blockquote><figure><a href="https://goo.gl/w4Pbea"><img alt src="https://hackernoon.com/hn-images/1*PZjwR1Nbluff5IMI6Y1T6g@2x.png"></a></figure>                <div class="archive-tags">                                        <a class="tag" href="https://hackernoon.com/tagged/advice">Advice</a>                                        <a class="tag" href="https://hackernoon.com/tagged/life-lessons">Life Lessons</a>                                        <a class="tag" href="https://hackernoon.com/tagged/technology">Technology</a>                                        <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                                        <a class="tag" href="https://hackernoon.com/tagged/programming">Programming</a>                  </div>                <div class="twitter-discussion">          <a target="_blank" href="https://twitter.com/search?q=https%3A%2F%2Fhackernoon.com%2Fyou-need-to-have-an-outstanding-design-to-write-awesome-code-3f7805e8e1dc">Continue the discussion <i class="fab fa-twitter"></i></a>        </div>