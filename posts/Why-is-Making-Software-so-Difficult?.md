<img src="https://hackernoon.com/drafts/l7fec30xi.png">                    <div class="paragraph">We often think of Software Development as a pursuit grounded in logic and clarity. There are stereotypes of software developers as devout followers of logic, more interested in binary digits than their fellow humans. From this perspective it can be shocking to discover that <a href="https://www.standishgroup.com/sample_research_files/CHAOSReport2015-Final.pdf">software projects have high failure rates</a> and that some projects fail to the tune of billions. How is this level of chaos possible in a logical discipline with scientists at the helm?</div><div class="paragraph">If we can better understand how projects are so subject to failure then we can learn to approach projects more safely in future. The most dangerous risks are the ones we don&#x2019;t see coming - especially if our way of thinking blinds us to them.&#xA0;</div><div class="paragraph"><strong>Stereotypes about Software Development</strong></div><div class="paragraph">Our image of Software Development as a logical pursuit is exemplified in the precise and strict syntactical rules of programming languages and applications composed from them. This pervades popular understanding as well as technical thinking. The rules of some applications can be clear to the user of the application when using it - simple games like space invaders typically have no page explaining the rules as we simply see them. Other times it may be clear an application has rules but what they are can be obscure, resulting in the familiar &#x2018;computer says no&#x2019; phenomenon. Either way the strictness of the rules tends to be felt and this influences our assumptions about software development.&#xA0;</div><div class="paragraph">Famous examples of computing problems are also a big part of our picture of software and these tend to be very strictly defined. Travelling salespeople in textbooks are subject to more constraints than in real life (they rarely get lifts or share jobs with colleagues or bunk off for a drink). We tend to heavily associate software engineering with examples about breaking secret codes, not so much with software that helps assess insurance claims.&#xA0;</div><div class="paragraph">But software developers are not all academics and do not all work on well-defined problems. Professional software development is about codifying rules to produce a system that meets a set of business objectives. It aims to produce artifacts of logic that will serve purposes in a messy world.&#xA0;</div><div class="paragraph">So, despite the pervasive picture of software development as strictly logical, the messiness of the world does have an important hand in the process of making software - software is made to play a role in the world. Projects can go wrong by making incorrect assumptions about the world or being confused about what they are trying to do.&#xA0;</div><div class="paragraph">Even so, this is only a partial explanation. How does it come about that software projects can be so risky and fail so often? How do we go about writing software?</div><div class="paragraph"><strong>Pictures of Software Development</strong></div><div class="paragraph">Software projects can vary immensely and the lifecycle of how projects are implemented can vary a great deal. It&#x2019;s quite tricky to form and hold a clear picture in one&#x2019;s head of the process of making software. It varies so much that to an extent one simply has to learn from experience. But having a clearer picture of software development will help us better appreciate the sources of risk in software development.</div><div class="paragraph">Given how abstract software development is it can be tempting to fall back on analogies to more concrete disciplines. Especially tempting can be an analogy to construction or physical engineering. So tempting is this analogy that it has historically influenced a great deal of software project management methodology (especially on the waterfall model). But we should be cautious about this:</div><blockquote>I&apos;m very suspicious of using metaphors of other professions to reason about software development. In particular, I believe the engineering metaphor has done our profession damage - in that it has encouraged the notion of separating design from construction.  <a href="http://martinfowler.com/bliki/MetaphoricQuestioning.html">Martin Fowler</a></blockquote><div class="paragraph">As Fowler points out, it is dangerous to think we know in advance what the problems are.&#xA0;</div><div class="paragraph">It is also dangerous to think we know in advance what the tools are. It is tempting to think that programmers write code and therefore the primary tools are programming languages. But contemporary commercial development relies a lot on existing tools and libraries which have to be chosen and applied to the task at hand. Programmers don&#x2019;t just write code to solve problems - programmers do a lot of writing code to stitch together the partial solutions of others. Depending on the choice it may be difficult to make a tool work for a particular purpose (requiring a lot of thought and stitching code) or routine or it may be practically impossible.&#xA0;</div><div class="paragraph">Construction also involves problems of tool selection. For example one has to choose types of brick or material for load-bearing and durability. The difference with software is the tools themselves are conceptual so the boundaries of what they do are harder to see clearly, at least without devoting very considerable time. It is not unusual to discover down the line that a chosen tool doesn&#x2019;t support the particular data format or communications protocol that we wanted it to.&#xA0;</div><div class="paragraph">Unchallenged early assumptions about tools can certainly lead to overruns and cost increases, which can contribute to failures. More damaging though tend to be unchallenged assumptions in the space of the business objectives. Here again the construction metaphor doesn&#x2019;t reflect the risk. There is certainly scope for mistaken assumptions to slip through about whether a building design provides enough space for the number of people who will use it and whether there are enough elevators. But visual plans help to bring out assumptions and the more concrete the realisation becomes the easier the assumptions are to find. Since software is abstract by nature it is difficult to make it concrete enough to flush out assumptions without entirely building the solution (by which point all the cost has been incurred).&#xA0;</div><div class="paragraph">Refining problem specifications to flush out assumptions can be more art than science. Refining specifications and choosing tools to address them are both central to what software developers do. Risk is inherent to both. Let&#x2019;s try to articulate a metaphor that expresses this better than the construction metaphor.&#xA0;</div><div class="paragraph"><strong>A Better Metaphor</strong></div><div class="paragraph">Software development is both logical and <em>creative</em> (and therein lies its chaos). There&#xA0;is&#xA0;a&#xA0;particular&#xA0;class&#xA0;of&#xA0;problems&#xA0;which&#xA0;are&#xA0;both creative and logical, a class which might be thought to fall under the heading of &#x2018;riddles&#x2019; (though I do not think everything called a &#x2018;riddle&#x2019; is necessarily a good fit). We can explore how creative problem-solving of this kind can serve as a metaphor for software development&#xA0;by&#xA0;considering&#xA0;a&#xA0;particular&#xA0;story&#xA0;of&#xA0;puzzle-solving&#xA0;from&#xA0;the&#xA0;old&#xA0;Norse&#xA0;saga&#xA0;of&#xA0;Ragnar&#xA0;Lodbrok.</div><div class="paragraph">As the story goes, Ragnar&#x2019;s men report to him that they have seen avery beautiful woman, Kraka. Ragnar&#x2019;s interest is aroused and he sends for her, but he decides to test her wits. He commands her to arrive neither dressed nor undressed, neither hungry nor full, and neither alone nor in company. Kraka is up&#xA0;to the challenge and arrives draped in a net and her long hair, biting an onion, and with only her dog as a companion. Ragnar is impressed and marries her.</div><div class="paragraph">Ragnar&#x2019;s request is not unlike the specification of a software project in at least one key respect. Ragnar does not entirely know what will satisfy his request until he sees it. He knows certain constraints that will need to be met but he will have no idea that the&#xA0;solution Kraka&#xA0;finds&#xA0;is a&#xA0;possible solution until&#xA0;he sees it.</div><div class="paragraph">To see the connection more clearly, let us imagine that Ragnar does not immediately marry Kraka. Instead he next specifies that Kraka should first prove her worth in an even more heroic exercise. He asks her to&#xA0;produce&#xA0;a system&#xA0;which will&#xA0;process the&#xA0;documentation approvals&#xA0;and rejections for which he currently employs a whole team. At the point of specification, Ragnar has little conception of how that task might be achieved without the need for a team.Much as with his previous riddle, Ragnar does not know it could be possible to process the documentations approval and rejections without a team. He needs to be shown the solution before he can know whether it does what he currently calls &#x2018;documentation approval and rejection.&#x2019;</div><div class="paragraph">It is important that in both cases Kraka has to take Ragnar into&#xA0;a kind of unknown territory. Ragnar is not sure of what things he would call &#x2018;neither dressed nor undressed.&#x2019; Similarly,&#xA0;Ragnar is not sure&#xA0;what he will call &#x2018;documentation approval and rejection&#x2019; without a team&#xA0;performing the&#xA0;approvals/rejections and Kraka has&#xA0;to&#xA0;understand&#xA0;these expressions sufficiently to come up with something that Ragnar will call a solution.</div><div class="paragraph">The basic uncertainty that goes along with software projects, then, is that we do not fully understand what the solution to our problems will&#xA0;be until we have a completed solution. If all goes well then one sees the solution take clearer and clearer shape as one goes through the project.This is the key difference between software projects and manufacturing&#xA0;projects &#x2013;with a&#xA0;manufacturing project&#xA0;one can&#xA0;form a&#xA0;relatively clear&#xA0;picture very&#xA0;early on&#xA0;of&#xA0;the product&#xA0;to be&#xA0;produced&#xA0;and&#xA0;then it&#xA0;can be&#xA0;precisely&#xA0;drawn&#xA0;up&#xA0;and&#xA0;physically&#xA0;constructed.&#xA0;In&#xA0;a&#xA0;manufacturing&#xA0;project&#xA0;one&#xA0;has&#xA0;the&#xA0;possibility&#xA0;of&#xA0;forming&#xA0;a&#xA0;clear&#xA0;picture&#xA0;early&#xA0;on&#xA0;because&#xA0;the&#xA0;product&#xA0;to&#xA0;be&#xA0;produced&#xA0;is&#xA0;a&#xA0;physical&#xA0;thing.&#xA0;A&#xA0;software&#xA0;product&#xA0;is&#xA0;abstract&#xA0;and&#xA0;the&#xA0;solutions to&#xA0;software&#xA0;problems&#xA0;are conceptual. (Software programs may be physically instantiated but this does not take away from their conceptual nature.)</div><div class="paragraph">If one is drawing up requirements for&#xA0;a physical product or structure, those requirements are by and large much easier to understand from the&#xA0;beginning than&#xA0;is the&#xA0;case with&#xA0;a software&#xA0;project. For&#xA0;example, if one wants to build a bridge then it is fairly clear from the beginning what it means to say that it needs to take a load of X many cars each weighing so much. Software requirements, by virtue of being abstract, are more likely to be hard to understand and can sometimes look like they are&#xA0;perfectly&#xA0;clear&#xA0;but&#xA0;turn&#xA0;out&#xA0;to&#xA0;be&#xA0;unclear&#xA0;in&#xA0;the&#xA0;light&#xA0;of&#xA0;later developments.</div><div class="paragraph">Let us go back to Kraka and Ragnar and imagine that Kraka arrives accompanied by a rabbit instead of a&#xA0;dog. Ragnar might say that he&#xA0;will not accept this as a solution &#x2013; he thinks that arriving with a rabbit does not count as being accompanied at all. If this seems implausible or unfair then perhaps imagine that Kraka arrives with a goldfish instead. It is plausible that we can find circumstances where Kraka and Ragnar will take different views of what counts as being &#x2018;accompanied.&#x2019; But it is Ragnar&#x2019;s view that counts since he set the problem.</div><div class="paragraph">A parallel of the dispute between Kraka and Ragnar takes place on software projects - developers can sometimes take a different view of what fits the problem to what end-users will find acceptable. Kraka could feasibly have sought to forestall such an issue by probing  the&#xA0;problem&#xA0;further&#xA0;from&#xA0;the&#xA0;beginning&#xA0;&#x2013; she&#xA0;might&#xA0;have&#xA0;done&#xA0;an equivalent of requirements analysis. We can imagine Kraka putting a&#xA0;business&#xA0;analyst&#xA0;hat on&#xA0;and&#xA0;asking&#xA0;questions&#xA0;like&#xA0;&#x2018;Do&#xA0;you&#xA0;mean accompanied by a human being? What about a pet?&#x2019; But even after much requirements analysis&#xA0;these types&#xA0;of ambiguities can remain. Even if it does become clear that Ragnar would accept a pet, it may not&#xA0;be made clear (not even to him until he sees it) that he would not accept a goldfish.</div><div class="paragraph"><strong>Uses of the Metaphor</strong></div><div class="paragraph">I personally find the logical problem-solving metaphor a useful fallback when I&apos;m tempted to look for a definite answer to whether a particular design will &apos;work&apos; or a chosen tool will fit a particular need. Sometimes we can&apos;t be sure of a solution in advance of providing it. We might very much want that upfront certainty but we just can&apos;t achieve it. </div><div class="paragraph">I also find the metaphor useful when there&#x2019;s a lot going on in a project and I need to better see the project dynamics - how the project is operating and where it is trying to get to. Thinking of a project through the open-ended comparison of logical problem solving can help me see the importance of aspects that I might otherwise overlook.&#xA0;It can give me a rationale to better understand the dynamics of a project rather than seeing a set of burn-down charts. If we see software projects as exercises in collective problem solving then we refocus our thinking away from the graphics of plans and instead towards the people and motivations driving the project.</div><div class="paragraph">This article is based on my<a href="https://github.com/ryandawsonuk/Writing-on-software/blob/master/Why%20Making%20Software%20is%20so%20Difficult.pdf"> &apos;Why Making Software is so Difficult&apos;, ACM SIGSOFT Software Engineering Notes 39</a><br></div>                    <h2 class="tags-header">Tags</h2>          <div class="archive-tags">                                                <a class="tag" href="https://hackernoon.com/tagged/software-engineering">Software Engineering</a>                                                <a class="tag" href="https://hackernoon.com/tagged/project-management">Project Management</a>                                                <a class="tag" href="https://hackernoon.com/tagged/latest-tech-stories">Latest Tech Stories</a>                                                <a class="tag" href="https://hackernoon.com/tagged/engineering-management">Engineering Management</a>                                                <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                                                <a class="tag" href="https://hackernoon.com/tagged/programming">Programming</a>                                                <a class="tag" href="https://hackernoon.com/tagged/software-development">Software Development</a>                                                <a class="tag" href="https://hackernoon.com/tagged/agile">Agile</a>                      </div>                              <div class="divider-title comments">            <div class="divider"></div>            <h1 class="more-heading">Comments</h1>            <div class="divider"></div>          </div>          <div class="comments">                                              </div>                              <div class="twitter-discussion">            <a target="_blank" href="https://community.hackernoon.com/t/13339">Continue the Discussion <i class="fas fa-comments-alt"></i></a>          </div>