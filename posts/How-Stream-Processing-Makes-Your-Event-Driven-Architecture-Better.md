<img src="https://hackernoon.com/drafts/yt26c2g9r.png">                    <div class="paragraph">If you&#x2019;re an architect or developer looking at event-driven architectures, stream processing might be just what you need to make your app faster, more scalable, and more decoupled.</div><div class="paragraph">In this article&#x2014;the third in a series about event-driven architectures&#x2014;we will review a little of <a href="https://hackernoon.com/best-practices-for-event-driven-microservice-architecture-e034p21lk">the first article in the series,</a> which outlined the benefits of event-driven architectures, some of the options, and a few patterns and anti-patterns. We will also review the <a href="https://hackernoon.com/scale-your-microservices-with-an-easy-message-queue-on-redis-e92n2gk3">second article</a>, which provided more detail on message queues and deployed a quick-start message queue using Redis and RSMQ.&#xA0;</div><div class="paragraph">This article will also dive deeper into stream processing. We will discuss why you might pick stream processing as your architecture, some of the pros and cons, and a quick-to-deploy reference architecture using <a href="https://kafka.apache.org/">Apache Kafka</a>.</div><h2>What is an Event-Driven Architecture?</h2><div class="paragraph">Stream processing is a type of event-driven architecture. In event-driven architectures, when a component performs some piece of work that other components might be interested in, that component (called a producer) produces an event&#x2014;a record of the performed action. Other components (called consumers) consume those events so that they can perform their own tasks as a result of the event.</div><div class="paragraph">This decoupling of consumers and producers gives event-driven architectures several benefits:</div><ul><li>Asynchronous&#x2014;Communications between components are asynchronous, avoiding any bottlenecks caused by synchronous, monolithic architectures.</li><li>Decoupled&#x2014;Components don&#x2019;t need to know about one another, and can be developed, tested, deployed, and scaled independently.</li><li>Easy Scaling&#x2014;Since components are decoupled, bottleneck issues can be more easily tracked to a single component, and quickly scaled.</li></ul><div class="paragraph">There are two main kinds of event-driven architectures: message queues and stream processing. Let&apos;s dive into the differences.</div><h2>Intro to Message Queues</h2><div class="paragraph">With message queues, the original event-driven architecture, the producer places a message into a queue targeted to a specific consumer. That message is held in the queue (often in first-in, first-out order) until the consumer retrieves it, at which time the message is deleted.&#xA0;</div><div class="paragraph">Message queues are useful for systems where you know exactly what needs to happen as a result of an event. When an issue occurs, your producer sends a message to the queue, targeted to some consumer(s). Those consumers obtain the message from the queue and then execute the next operation. </div><div class="paragraph">Once that next step is taken, the event is removed from the queue forever. In the case of message queues, the flow is generally known by the queue, giving rise to the term &#x201C;smart broker/dumb consumer&#x201D;, which means the broker (queue) knows where to send a message, and the consumer is just reacting.</div><h2>Intro to Stream Processing</h2><div class="paragraph">With stream processing, messages are not targeted to a certain recipient, but rather are published at-large to a specific topic and available to all interested consumers. Any and all interested recipients can subscribe to that topic and read the message. Since the message must be available to all consumers, the message is not deleted when it is read from the stream.</div><div class="paragraph">Producers and brokers don&#x2019;t need or want to know what will happen as a result of a message, or where that message will go. The producer just sends the message to broker, the broker publishes it, and the producer and broker move on. Interested consumers receive the message and complete their processing. Because of this further decoupling, systems with event streaming can evolve easily as the project evolves.&#xA0;</div><div class="paragraph">Consumers can be added and deleted and can change how and what they process, regardless of the overall system. The producer and the broker don&#x2019;t need to know about these changes because the services are decoupled. This is often referred to as &#x201C;dumb broker/smart consumer&#x201D;&#x2014;the broker (stream) is just a broker, and has no knowledge of routing. The consumers in message processing are the smart components; they are aware of what messages to listen for.</div><div class="paragraph">Also, consumers can retrieve multiple messages at the same time and since messages are not deleted, consumers can replay a series of messages going back in time. For example, a new consumer can go back and read older messages from before that consumer was deployed.</div><div class="paragraph">Stream processing has become the go-to choice for many event-driven systems. It offers several advantages over message queues including multiple consumers, replay of events, and sliding window statistics. Overall, you gain a major increase in flexibility.</div><h2>Should You Use Stream Processing or Message Queues?</h2><div class="paragraph">Here are a several use cases for each:</div><div class="paragraph"><strong>Message Queues</strong></div><div class="paragraph">Message queues, such as <a href="https://www.rabbitmq.com/">RabbitMQ</a> and <a href="https://activemq.apache.org/">ActiveMQ</a> are popular. Message queues are particularly helpful in systems where you have known or complex routing logic, or when you need to guarantee a single delivery of each message.</div><div class="paragraph">A typical use case for message queues is a busy ecommerce&#xA0;website where your services must be highly available, your requests must be delivered, and your routing logic is known and unlikely to change. With these constraints, message queues give you the powerful advantages of asynchronous communication and decoupled services, while keeping your architecture simple.</div><div class="paragraph">Additional use cases often involve system dependencies or constraints, such as a system having a frontend and backend written in different languages or a need to integrate into legacy infrastructure.</div><div class="paragraph"><strong>Stream Processing</strong></div><div class="paragraph">Stream processing is useful for systems with more complex consumers of messages such as:</div><ul><li><strong>Website Activity Tracking</strong>. Activity on a busy website creates a lot of messages. Using streams, you can create a series of real-time feeds, which include page views, clicks, searches, and so on, and allow a wide range of consumers to monitor, report on, and process this data.</li><li><strong>Log Aggregation</strong>. Using streams, log files can be turned into a centralized stream of logging messages that are easy for consumers to consume. You can also calculate sliding window statistics for metrics, such as an average every second or minute. This can greatly reduce the output data volumes, making your infrastructure more efficient.</li><li><strong>IOT</strong>. IOT also produces a lot of messages. Streams can handle a large volume of messages, and publish them to a large number of consumers in a highly scalable and performant manner.</li><li><strong>Event Sourcing</strong>. As described in <a href="https://dev.to/heroku/best-practices-for-event-driven-microservice-architecture-2lh7">a previous article</a>, streams can be used to implement <a href="https://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>, where updates and deletes are never performed directly on the data; rather, state changes of an entity are saved as a series of events.</li><li><strong>Messaging</strong>. Complex and highly-available messaging platforms such as Twitter and LinkedIn use streams (Kafka) to drive metrics, deliver messages to news feeds, and so on.&#xA0;</li></ul><h2>A Reference Architecture Using Kafka</h2><div class="paragraph">In our previous article, we deployed a quick-to-stand-up message queue to learn about queues. Let&#x2019;s do a similar example stream processing.</div><div class="paragraph">There are many options for stream processing architectures, including the following:</div><ul><li>Apache Kafka</li><li>Apache Spark</li><li>Apache Beam/Google Cloud Data Flow</li><li>Spring Cloud Data Flow</li></ul><div class="paragraph">We&apos;ll use the <a href="https://devcenter.heroku.com/articles/event-driven-microservices-with-apache-kafka">Apache Kafka reference architecture on Heroku</a>. <a href="http://heroku.com/">Heroku</a> is a&#xA0;cloud platform-as a service (PaaS) that offers <a href="https://devcenter.heroku.com/categories/kafka">Kafka as an add-on</a>. Their cloud platform makes it easy to deploy a streaming system rather than hosting or running your own. Since Heroku provides a <a href="https://github.com/heroku-examples/edm-terraform">Terraform script</a> that deploys all the needed code and configuration for you in one step, it&apos;s a quick and easy way to learn about stream processing.</div><div class="paragraph">We won&#x2019;t walk through the deployment steps here, as they are outlined in <a href="https://devcenter.heroku.com/articles/event-driven-microservices-with-apache-kafka">detail on the reference architecture page.</a> However, it deploys an example ecommerce&#xA0;system that showcases the major components and advantages of stream processing. Clicks to browse or purchase products are recorded as events to Kafka.</div><div class="image-container"><img src="https://hackernoon.com/photos/XnOdQ9ymHwTqEaXbwoUc7yrZKIu2-kf1z22gf7" alt></div><div class="paragraph">Here is a key snippet of code from <a href="https://github.com/trevorscott/edm-relay/blob/master/index.js">edm-relay</a>, which sends messages to the Kafka stream. It&apos;s quite simple to publish events to Kafka since it&apos;s only a matter of calling the producer API to insert a JSON object.</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code>app.post(<span style="color:#b9ca4a">&apos;/produceClickMessage&apos;</span>, <span class="hljs-function"><span style="color:#c397d8">function</span> (<span style="color:#e78c45">req, res</span>) </span>{&#xA0; &#xA0;<span style="color:#c397d8">try</span> {&#xA0; &#xA0; &#xA0;<span style="color:#c397d8">const</span> topic = <span style="color:#b9ca4a">`<span class="hljs-subst">${process.env.KAFKA_PREFIX}</span><span class="hljs-subst">${req.body.topic}</span>`</span>;&#xA0; &#xA0; &#xA0;<span style="color:#e78c45">console</span>.log(<span style="color:#b9ca4a">`topic: <span class="hljs-subst">${topic}</span>`</span>);&#xA0; &#xA0; &#xA0;producer.produce(&#xA0; &#xA0; &#xA0; &#xA0;topic,&#xA0; &#xA0; &#xA0; &#xA0;<span style="color:#e78c45">null</span>,&#xA0; &#xA0; &#xA0; &#xA0;<span style="color:#969896">// Message to send. Must be a buffer</span>&#xA0; &#xA0; &#xA0; &#xA0;Buffer.from(<span style="color:#e78c45">JSON</span>.stringify(req.body)),&#xA0; &#xA0; &#xA0; &#xA0;<span style="color:#969896">// for keyed messages, we also specify the key - note that this field is optional</span>&#xA0; &#xA0; &#xA0; &#xA0;<span style="color:#e78c45">null</span>,&#xA0; &#xA0; &#xA0; &#xA0;<span style="color:#969896">// you can send a timestamp here. If your broker version supports it,</span>&#xA0; &#xA0; &#xA0; &#xA0;<span style="color:#969896">// it will get added. Otherwise, we default to 0</span>&#xA0; &#xA0; &#xA0; &#xA0;<span style="color:#e78c45">Date</span>.now(),&#xA0; &#xA0; &#xA0;);&#xA0; &#xA0;} <span style="color:#c397d8">catch</span> (err) {&#xA0; &#xA0; &#xA0;<span style="color:#e78c45">console</span>.error(<span style="color:#b9ca4a">&apos;A problem occurred when sending our message&apos;</span>);&#xA0; &#xA0; &#xA0;<span style="color:#c397d8">throw</span> err;&#xA0; &#xA0;}&#xA0; &#xA0;res.status(<span style="color:#e78c45">200</span>).send(<span style="color:#b9ca4a">&quot;{\&quot;message\&quot;:\&quot;Success!\&quot;}&quot;</span>)&#xA0;});</code></pre></div><div class="paragraph">A real-time dashboard then consumes the stream of click events and displays analytics. This could be useful for business analytics to explore the most popular products, changing trends, and so on.</div><div class="image-container"><img src="https://hackernoon.com/photos/XnOdQ9ymHwTqEaXbwoUc7yrZKIu2-8622k2gr5" alt></div><div class="paragraph">Here is the code from <a href="https://github.com/trevorscott/edm-stream/blob/master/index.js">edm-stream</a> that subscribes to the topic:</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code>.on(<span style="color:#b9ca4a">&apos;ready&apos;</span>, (id, metadata) =&gt; {&#xA0; &#xA0;consumer.subscribe(kafkaTopics); &#xA0;&#xA0; &#xA0;consumer.consume();&#xA0; &#xA0;consumer.on(<span style="color:#b9ca4a">&apos;error&apos;</span>, err =&gt; {&#xA0; &#xA0; &#xA0;<span style="color:#e78c45">console</span>.log(<span style="color:#b9ca4a">`! &#xA0; &#xA0; &#xA0;Error in Kafka consumer: <span class="hljs-subst">${err.stack}</span>`</span>);&#xA0; &#xA0;});&#xA0; &#xA0;<span style="color:#e78c45">console</span>.log(<span style="color:#b9ca4a">&apos;Kafka consumer ready.&apos;</span> + <span style="color:#e78c45">JSON</span>.stringify(metadata));&#xA0; &#xA0;clearTimeout(connectTimoutId);&#xA0;})</code></pre></div><div class="paragraph">and then consumes the message from the stream by calling an event handler for each message:</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code>.on(<span style="color:#b9ca4a">&apos;data&apos;</span>, <span class="hljs-function"><span style="color:#c397d8">function</span>(<span style="color:#e78c45">data</span>) </span>{&#xA0; &#xA0;<span style="color:#c397d8">const</span> message = data.value.toString()&#xA0; &#xA0;<span style="color:#e78c45">console</span>.log(message, <span style="color:#b9ca4a">`Offset: <span class="hljs-subst">${data.offset}</span>`</span>, <span style="color:#b9ca4a">`partition: <span class="hljs-subst">${data.partition}</span>`</span>, <span style="color:#b9ca4a">`consumerId: edm/<span class="hljs-subst">${process.env.DYNO || <span style="color:#b9ca4a">&apos;localhost&apos;</span>}</span>`</span>);&#xA0; &#xA0;socket.sockets.emit(<span style="color:#b9ca4a">&apos;event&apos;</span>, message);&#xA0; &#xA0;consumer.commitMessage(data);&#xA0;})</code></pre></div><div class="paragraph">The reference architecture is not just about buying coffee; it&apos;s a starting point for any web app where you want to track clicks and report in a real-time dashboard. It&apos;s open source, so feel free to experiment and modify it according to your own needs.</div><div class="image-container"><img src="https://hackernoon.com/photos/XnOdQ9ymHwTqEaXbwoUc7yrZKIu2-9o2402g55" alt></div><div class="paragraph">Stream processing not only decouples your components so that they are easy to build, test, deploy, and scale independently, but also adds yet another layer of decoupling by creating a &#x201C;dumb&#x201D; broker between your components.</div><h2>Next Steps</h2><div class="paragraph">If you haven&#x2019;t already,&#xA0;read our other articles in this series on the <a href="https://dev.to/heroku/best-practices-for-event-driven-microservice-architecture-2lh7">advantages of event-driven architecture</a> and <a href="https://hackernoon.com/scale-your-microservices-with-an-easy-message-queue-on-redis-e92n2gk3">deploying a sample message queue using Redis and RSMQ</a>.</div>                    <h2 class="tags-header">Tags</h2>          <div class="archive-tags">                                                <a class="tag" href="https://hackernoon.com/tagged/microservices">Microservices</a>                                                <a class="tag" href="https://hackernoon.com/tagged/scalability">Scalability</a>                                                <a class="tag" href="https://hackernoon.com/tagged/javascript">Javascript</a>                                                <a class="tag" href="https://hackernoon.com/tagged/heroku">Heroku</a>                                                <a class="tag" href="https://hackernoon.com/tagged/kafka">Kafka</a>                                                <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                                                <a class="tag" href="https://hackernoon.com/tagged/architecure">Architecure</a>                                                <a class="tag" href="https://hackernoon.com/tagged/latest-tech-stories">Latest Tech Stories</a>                      </div>                              <div class="divider-title comments">            <div class="divider"></div>            <h1 class="more-heading">Comments</h1>            <div class="divider"></div>          </div>          <div class="comments">                                              </div>                              <div class="twitter-discussion">            <a target="_blank" href="https://community.hackernoon.com/t/19848">Continue the Discussion <i class="fas fa-comments-alt"></i></a>          </div>