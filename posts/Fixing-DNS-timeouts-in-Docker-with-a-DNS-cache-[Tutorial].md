<img src="https://hackernoon.com/drafts/jjhq3299.png">                    <div class="paragraph">Having flaky tests in your CI is a nightmare. You can&apos;t tell whether your new code broke something or if it&apos;s just those tests being flaky again. So anytime we see strange, random failures in CI for our open source project, Adapt, we try to track down the culprit ASAP. This is the story of how we discovered we were (accidentally) flooding our DNS server with traffic and how we used a DNS cache in Docker to solve the problem.</div><h2><a></a><a href="https://adaptjs.org/blog/2019/10/14/fixing-dns-timeouts-in-docker#background"></a>Background</h2><div class="paragraph">One of the open source projects I work on, <a href="https://adaptjs.org">AdaptJS</a> can deploy apps into multiple clouds and technologies, so there&apos;s a ton of system testing and end-to-end testing with Docker, Kubernetes, AWS, Google Cloud and other similar technologies.</div><div class="paragraph">We make heavy use of Docker in our tests, so we end up creating lots of short-lived containers that start up, do some work, like building or installing an app, and then get deleted. And as we added more and more of those tests, we started seeing previously stable system tests fail randomly in CI.</div><h2><a></a><a href="https://adaptjs.org/blog/2019/10/14/fixing-dns-timeouts-in-docker#the-symptom-test-timeouts"></a>The symptom: test timeouts</h2><div class="paragraph">The first symptoms we saw were test timeouts. We have fairly short timeouts on many of our end-to-end tests so we can detect if new code suddenly makes things take longer for end users. But now, a test that should normally take a half second would&#xA0;<strong>sometimes</strong>&#xA0;take 5.5 seconds.</div><div class="paragraph">The additional 5 seconds was a great clue--5 seconds sounded like it could be a timeout of some kind. Armed with that hunch, we looked back through all the seemingly random test failures and found the common thread: they were all tests that initiated network requests. We also noticed a few tests that had taken even longer to fail...always in increments of 5 seconds.</div><div class="paragraph">There weren&apos;t too many network protocols that could be involved here, so some quick Googling pointed us in the right direction. The default timeout for DNS server queries on Linux just&#xA0;<a href="https://linux.die.net/man/5/resolv.conf">happens to be 5 seconds</a>.</div><div class="paragraph">To see what was going on with DNS, we reached for probably the single most important tool for debugging network issues on Linux:&#xA0;<a href="https://www.tcpdump.org/">tcpdump</a>. (Or, if you prefer a GUI version,&#xA0;<a href="https://www.wireshark.org/">wireshark</a>&#xA0;is great too.) We ran tcpdump on the host system (an Amazon Workspaces Linux instance) and used a filter to see the DNS traffic:</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code><span style="color:#e78c45">$</span><span class="bash"> tcpdump -n -i eth1 port 53</span>11:35:59.474735 IP 172.16.0.131.54264 &gt; 172.16.0.119.domain: 64859+ AAAA? registry-1.docker.io. (38)11:35:59.474854 IP 172.16.0.131.49631 &gt; 172.16.0.119.domain: 43524+ A? registry-1.docker.io. (38)11:35:59.476871 IP 172.16.0.119.domain &gt; 172.16.0.131.49631: 43524 8/0/1 A 34.197.189.129, A 34.199.40.84, A 34.199.77.19, A 34.201.196.144, A 34.228.211.243, A 34.232.31.24, A 52.2.186.244, A 52.55.198.220 (177)11:35:59.476957 IP 172.16.0.119.domain &gt; 172.16.0.131.54264: 64859 0/1/1 (133)</code></pre></div><div class="paragraph">The first thing that we noticed was that we were generating a huge flood of DNS queries to the AWS default DNS server for our VPC. It looked like all those short-lived containers tended to do a bunch of DNS lookups when starting up, for various reasons. Next, we noticed that some of those DNS queries just went unanswered.</div><div class="paragraph">It&apos;s pretty common for shared DNS servers to implement rate limits so that a single user can&apos;t degrade performance for everyone else. Here, we suspected that the AWS DNS servers were doing exactly that. We weren&#x2019;t able to find a way to confirm whether we were actually hitting AWS rate limits, but it seemed wise for us not to DoS our DNS server.</div><h2><a></a><a href="https://adaptjs.org/blog/2019/10/14/fixing-dns-timeouts-in-docker#the-solution-a-docker-dns-cache-using-dnsmasq"></a>The solution: a Docker DNS cache, using dnsmasq</h2><div class="paragraph">In order to isolate DNS traffic within the host, we needed a local DNS server to act as a cache. A great choice for a cache like this is&#xA0;<a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">dnsmasq</a>. It&#x2019;s reliable, widely used, and super simple to set up. And since all of our testing runs inside Docker containers, it made sense to run the DNS server in Docker too.</div><div class="paragraph">The basic idea is pretty simple: run a dnsmasq container as the DNS cache on the Docker host network and then run our test containers with the&#xA0;<a href="https://docs.docker.com/engine/reference/run/#network-settings"><pre><code>--dns</code></pre> option</a>&#xA0;pointing to the cache container&#x2019;s IP address.</div><div class="paragraph">Here&#x2019;s the&#xA0;<pre><code>dns_cache</code></pre>&#xA0;script that starts the DNS cache container:</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code><span style="color:#e78c45">#!/usr/bin/env bash</span>: <span style="color:#b9ca4a">&quot;<span style="color:#d54e53">${IMAGE:=andyshinn/dnsmasq:2.76}</span>&quot;</span>: <span style="color:#b9ca4a">&quot;<span style="color:#d54e53">${NAME:=dnsmasq}</span>&quot;</span>: <span style="color:#b9ca4a">&quot;<span style="color:#d54e53">${ADAPT_DNS_IP_FILE:=/tmp/adapt_dns_ip}</span>&quot;</span><span style="color:#969896"># Get IP address for an interface, as visible from inside a container</span><span style="color:#969896"># connected to the host network</span><span class="hljs-function"><span style="color:#7aa6da">interfaceIP</span></span>() {    <span style="color:#969896"># Run a container and get ifconfig output from inside</span>    <span style="color:#969896"># We need the ifconfig that will be visible from inside the dnsmaq</span>    <span style="color:#969896"># container</span>    docker run --rm --net=host busybox ifconfig <span style="color:#b9ca4a">&quot;<span style="color:#d54e53">$1</span>&quot;</span> 2&gt;/dev/null | \        awk <span style="color:#b9ca4a">&apos;/inet /{print(gensub(/^.*inet (addr:)?([0-9.]+)\s.*$/, &quot;\\2&quot;, 1))}&apos;</span>}<span style="color:#c397d8">if</span> docker inspect --<span style="color:#e78c45">type</span> container <span style="color:#b9ca4a">&quot;<span style="color:#d54e53">${NAME}</span>&quot;</span> &gt;&amp; /dev/null ; <span style="color:#c397d8">then</span>    <span style="color:#c397d8">if</span> [ -f <span style="color:#b9ca4a">&quot;<span style="color:#d54e53">${ADAPT_DNS_IP_FILE}</span>&quot;</span> ]; <span style="color:#c397d8">then</span>        <span style="color:#969896"># dnsmasq is already started</span>        cat <span style="color:#b9ca4a">&quot;<span style="color:#d54e53">${ADAPT_DNS_IP_FILE}</span>&quot;</span>        <span style="color:#e78c45">exit</span> 0    <span style="color:#c397d8">else</span>        <span style="color:#e78c45">echo</span> DNS cache container running but file <span style="color:#d54e53">${ADAPT_DNS_IP_FILE}</span> does not exist. &gt;&amp;2        <span style="color:#e78c45">exit</span> 1    <span style="color:#c397d8">fi</span><span style="color:#c397d8">fi</span><span style="color:#969896"># We only support attaching to the default (host) bridge named &quot;bridge&quot;.</span>DOCKER_HOST_NETWORK=bridge<span style="color:#969896"># Confirm that &quot;bridge&quot; is the default bridge</span>IS_DEFAULT=$(docker network inspect <span style="color:#b9ca4a">&quot;<span style="color:#d54e53">${DOCKER_HOST_NETWORK}</span>&quot;</span> --format <span style="color:#b9ca4a">&apos;{{(index .Options &quot;com.docker.network.bridge.default_bridge&quot;)}}&apos;</span>)<span style="color:#c397d8">if</span> [ <span style="color:#b9ca4a">&quot;<span style="color:#d54e53">${IS_DEFAULT}</span>&quot;</span> != <span style="color:#b9ca4a">&quot;true&quot;</span> ]; <span style="color:#c397d8">then</span>    <span style="color:#e78c45">echo</span> Cannot start DNS cache. The Docker network named \<span style="color:#b9ca4a">&quot;<span style="color:#d54e53">${DOCKER_HOST_NETWORK}</span>\&quot; does not exist or is not the default bridge. &gt;&amp;2    exit 1fi# Get the Linux interface name for the bridge, typically &quot;</span>docker0<span style="color:#b9ca4a">&quot;INTF_NAME=<span style="color:#d54e53">$(docker network inspect &quot;${DOCKER_HOST_NETWORK}&quot; --format &apos;{{(index .Options &quot;com.docker.network.bridge.name&quot;)</span>}}&apos;)if [ -z &quot;</span><span style="color:#d54e53">${INTF_NAME}</span><span style="color:#b9ca4a">&quot; ]; then    echo Cannot start DNS cache. Unable to determine default bridge interface name. &gt;&amp;2    exit 1fi# Get the IP address of the bridge interface. This is the address that# dnsmasq will listen on and other containers will send DNS requests to.IP_ADDR=<span style="color:#d54e53">$(interfaceIP &quot;${INTF_NAME}&quot;)</span>if [ -z &quot;</span><span style="color:#d54e53">${IP_ADDR}</span><span style="color:#b9ca4a">&quot; ]; then    echo Cannot start DNS cache. Docker bridge interface <span style="color:#d54e53">${INTF_NAME}</span> does not exist. &gt;&amp;2    exit 1fi# Run the dnsmasq container. The hosts&apos;s /etc/resolv.conf configuration will# be used by dnsmasq to resolve requests.docker run --rm -d --cap-add=NET_ADMIN --name &quot;</span><span style="color:#d54e53">${NAME}</span><span style="color:#b9ca4a">&quot; --net=host -v/etc/resolv.conf:/etc/resolv.conf &quot;</span><span style="color:#d54e53">${IMAGE}</span><span style="color:#b9ca4a">&quot; --bind-interfaces --listen-address=&quot;</span><span style="color:#d54e53">${IP_ADDR}</span><span style="color:#b9ca4a">&quot; --log-facility=- &gt; /dev/nullif [ $? -ne 0 ]; then    echo Cannot start DNS cache. Docker run failed.    exit 1fi# Remember what IP address to use as DNS server, then output it.echo <span style="color:#d54e53">${IP_ADDR}</span> &gt; &quot;</span><span style="color:#d54e53">${ADAPT_DNS_IP_FILE}</span><span style="color:#b9ca4a">&quot;echo <span style="color:#d54e53">${IP_ADDR}</span></span></code></pre></div><div class="paragraph">In addition to starting the container (if it&#x2019;s not already running), the script outputs the cache container&#x2019;s IP address. We&#x2019;ll use that on the command line of any other containers we start. The script also ensures that dnsmasq only listens for DNS requests within Docker (on the Docker bridge interface), so there&#x2019;s a little additional work to determine the IP address to listen on.</div><div class="paragraph">Here&#x2019;s an example of how to start the DNS cache, remembering the IP address in variable&#xA0;<pre><code>DNS_IP</code></pre>&#xA0;and then running another container that will use the cache.</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code><span style="color:#e78c45">$</span><span class="bash"> DNS_IP=$(dns_cache)</span><span style="color:#e78c45">$</span><span class="bash"> docker run --dns <span style="color:#d54e53">${DNS_IP}</span> --rm busybox ping -c1 adaptjs.org</span></code></pre></div><h2>Verifying the cache works</h2><div class="paragraph">After we started using the cache in our testing, the number of DNS queries that the host system sent to the AWS DNS server dropped to a small trickle. We also confirmed that the cache was operating properly by checking the dnsmasq statistics. Sending a&#xA0;<pre><code>SIGUSR1</code></pre>&#xA0;to dnsmasq causes it to&#xA0;<a href="http://www.thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html">print statistics to its log</a>:</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code><span style="color:#e78c45">$</span><span class="bash"> docker <span style="color:#e78c45">kill</span> -s USR1 dnsmasq</span><span style="color:#e78c45">$</span><span class="bash"> docker logs dnsmasq</span>dnsmasq[1]: cache size 150, 1085/4664 cache insertions re-used unexpired cache entries.dnsmasq[1]: queries forwarded 1712, queries answered locally 3940dnsmasq[1]: queries for authoritative zones 0dnsmasq[1]: server 172.16.0.119#53: queries sent 1172, retried or failed 0dnsmasq[1]: server 172.16.1.65#53: queries sent 252, retried or failed 0dnsmasq[1]: server 172.16.0.2#53: queries sent 608, retried or failed 0</code></pre></div><div class="paragraph">And most importantly, we saw a dramatic decrease in system test timeouts and our CI runs stabilized.</div><div class="paragraph">This issue took us a while to track down. But keeping CI healthy is extremely important. If you have too many sporadic test failures, developers tend to ignore CI results and push potentially broken code.</div><div class="paragraph">So, even though it was time consuming to track down these failures, given the ease of the fix, it was definitely worth the investment.</div><div class="Divider"><i></i><i></i><i></i><i></i><i></i><i></i></div><div class="paragraph"><em>Originally published on the </em><a href="https://adaptjs.org/blog/2019/10/14/fixing-dns-timeouts-in-docker"><em>Adapt blog</em></a><em>.</em></div>                    <h2 class="tags-header">Tags</h2>          <div class="archive-tags">                                                <a class="tag" href="https://hackernoon.com/tagged/programming">Programming</a>                                                <a class="tag" href="https://hackernoon.com/tagged/docker">Docker</a>                                                <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                                                <a class="tag" href="https://hackernoon.com/tagged/software-development">Software Development</a>                                                <a class="tag" href="https://hackernoon.com/tagged/testing">Testing</a>                                                <a class="tag" href="https://hackernoon.com/tagged/dns">Dns</a>                                                <a class="tag" href="https://hackernoon.com/tagged/react">React</a>                                                <a class="tag" href="https://hackernoon.com/tagged/latest-tech-stories">Latest Tech Stories</a>                      </div>                                        <div class="twitter-discussion">            <a target="_blank" href="https://community.hackernoon.com/t/16081">Continue the Discussion <i class="fas fa-comments-alt"></i></a>          </div>