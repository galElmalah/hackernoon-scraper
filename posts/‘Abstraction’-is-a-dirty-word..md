<figure><img alt src="https://hackernoon.com/hn-images/1*6cqVmlfEDgFUZCXVyRhEDA.png"></figure><p>We programmers have many tools at our disposal and lofty concepts we can use&#x200A;&#x2014;&#x200A;but that doesn&#x2019;t mean we&#xA0;should.</p><p>Abstraction, I am often told, is &#x201C;the core concept of programming&#x201D;. It is true that without it, we would be writing software in byte code, scratching our heads and looking for new careers. Abstraction gave us C. It gave us all manner of languages and concepts with which to express ourselves&#x200A;&#x2014;&#x200A;as is each programmer&#x2019;s right. However, some programmers shout &#x2018;abstraction&#x2019; from the rooftops and peddle it as a salve to all programming woes and I get all&#xA0;fidgety.</p><p>The problem, I have found, is not abstraction itself but that the word is sometimes used to mean: indirection, hidden behaviour and additional complexity&#x200A;&#x2014;&#x200A;though they will tell you it makes everything so simple. And who could blame them? We have lots of buzzwords to help the budding abstracter like: interfaces, inheritance and encapsulation. Unfortunately, just because a child can reach the scissors, it does not mean they should always use&#xA0;them.</p><p>For example, when I was new to programming, I was preoccupied with interfaces that could be &#x2018;swapped out&#x2019; and modelling problems using dozens of classes with hidden, volatile&#xA0;state.</p><p><strong>Interfaces</strong></p><p>If you think you&#x2019;re writing software that will survive, unchanged and perfectly functional for decades, you&#x2019;re probably wrong and I&#x2019;m sorry. If you do work on that project, then you are likely to make some poor programmer&#x2019;s life a living hell as he&#x2019;ll be booting up Windows XP or Internet Explorer 9 in&#xA0;2030.</p><p>People like to use interfaces because: what&#xA0;if?</p><blockquote>&#x201C;What if we want to swap out the rendering library in the future? It will be easy because it&#x2019;s hidden behind this handy interface.&#x201D;</blockquote><p>If you&#x2019;re implementing features and making these kinds of decisions then you&#x2019;re not implementing features&#x200A;&#x2014;&#x200A;you&#x2019;re wrapping yourself in a comfortable blanket of speculation. Not once have I seen this decision pay off. If you <em>do </em>end up changing technology, your interface, invariably, won&#x2019;t be quite right and things will need tweaking. If you have to tweak an interface and its callers, then you may as well have not bothered. So don&#x2019;t&#xA0;bother.</p><p><strong>Conceptual classes</strong></p><p>Another temptation I started out with, was to build a tower of classes with internal, hidden state and behaviours&#x200A;&#x2014;&#x200A;to map my problem to some more tangible concepts rather than deal directly with the complexity of the&#xA0;data.</p><p>It is a vice that piggybacks on the misconception that encapsulation is king. Encapsulation is court jester at best. As software grows more complex, it becomes harder to reason about the interaction between these types of objects within your application, making it harder to debug. Future programmer&#x2019;s&#x200A;&#x2014;&#x200A;including you in three months&#x200A;&#x2014;&#x200A;will struggle to reason about what your software actually does and how. It is telling to me that abstracters often balk at making small changes or quick fixes as software&#xA0;grows.</p><p>I am not saying &#x2018;don&#x2019;t use the tools that OOP introduced&#x2019;, I know some good programmers who do and from time to time it&#x2019;s necessary. I am, however, suggesting that you implement exactly what is required and nothing more. <a href="http://www.dataorienteddesign.com/dodmain/node3.html#SECTION00310000000000000000">Software is just data</a>: input, processing and then output and my best code has always been that which does the simplest thing to get the job done. My more recent stuff is also mostly functional, but more of that another time. For now, you might enjoy <a href="https://www.youtube.com/watch?v=rX0ItVEVjHc">this talk</a> from <a href="https://medium.com/u/c8b369cca97b">Mike Acton</a> on data-oriented design in&#xA0;C++.</p>                <div class="archive-tags">                                        <a class="tag" href="https://hackernoon.com/tagged/programming">Programming</a>                                        <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                                        <a class="tag" href="https://hackernoon.com/tagged/functional-programming">Functional Programming</a>                                        <a class="tag" href="https://hackernoon.com/tagged/technology">Technology</a>                  </div>                <div class="twitter-discussion">          <a target="_blank" href="https://twitter.com/search?q=https%3A%2F%2Fhackernoon.com%2Fabstract-programmers-acada09df860">Continue the discussion <i class="fab fa-twitter"></i></a>        </div>