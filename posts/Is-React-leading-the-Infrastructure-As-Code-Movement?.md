<img src="https://hackernoon.com/drafts/e75t2dsn.png">                    <div class="paragraph">What is &quot;Infrastructure as Code&quot;? If someone checks a bunch of YAML files into a Git repository, do they suddenly become code? That seems more like &quot;Infrastructure as Files&quot; to me. I suppose that&apos;s better than infrastructure as a gaggle of shell scripts and some commands run by hand in the middle of the night in a coffee-fueled haze, but it is a far cry from code. How about a system to define infrastructure that really is like code?</div><blockquote>How about a system to define infrastructure that really is like code?</blockquote><div class="paragraph">Real code -- well-written code -- uses concepts that are largely absent from today&apos;s Infrastructure as Code technologies. These concepts are abstraction, modularity, composability, and reusability. In code, you can import a library (reusability) and use its functionality to build your own library (composability). Moreover, you don&apos;t need to know the implementation of the library to use it (abstraction). You can even divide up the coding effort among different teams by agreeing on an interface (modularity).</div><div class="paragraph">If we really had Infrastructure as Code, we wouldn&apos;t see every <br>deployment system rolling its own complex deployment implementations. But today, everyone rolls their own. Using <a href="https://aws.amazon.com/fargate/">AWS Fargate</a>? Great! It has a <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">blue-green deployment</a> mechanism built in. Want to use the same logic to blue-green something that isn&apos;t using Fargate? Too bad!</div><div class="paragraph">With proper Infrastructure as Code, you should have an abstract, reusable, component that knows how to blue-green deploy anything that meets a certain interface. And you should then be able to instantiate that blue-green component, and specify what you want to blue-green (<a href="https://kubernetes.io">Kubernetes</a> <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">Pods</a>, <a href="https://aws.amazon.com/ec2/">AWS EC2 Instances</a>, etc.). Just like you do in real code.</div><div class="paragraph">We set out to address this problem head on by creating a open source <br>system that lets you specify your entire application architecture with <br>reusable library components, while still making it easy to stitch <br>together custom components when you need them. You know, just like you do with actual code.</div><div class="paragraph">We wanted these libraries to be modular, composable and reusable.<br>We wanted everyone to be able to contribute components so that you can <br>stitch the best ones together with your own to create your own unique <br>architecture. And we wanted it to be easy to get started and easy to use, but still powerful enough for mission critical applications.</div><div class="paragraph">We call this system <a href="https://adaptjs.org">Adapt</a>, which is essentially <a href="https://reactjs.org">ReactJS</a>, but for infrastructure.</div><div class="paragraph">Why use a web front-end technology? Because the requirements for a good Infrastructure as Code system look a lot like those for a good front-end framework:</div><ul><li>A declarative specification of what to instantiate. (React apps use a <a href="https://en.wikipedia.org/wiki/Document_Object_Model">DOM</a>.)</li><li>A declarative syntax when possible. (React uses <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a>.)</li><li>Imperative code to stitch together declarative snippets. (React allows JavaScript to assemble JSX snippets.)</li><li>Specification of state-based infrastructure updates like blue-green deploy or fail-over. (React was built to make this easy.)</li><li>Components that can encapsulate these state-based updates. (<a href="https://reactjs.org/docs/hooks-intro.html">React hooks</a> let components do exactly this.)</li><li>Components that are easy to write, easy to use, and easy to compose. (The whole point of React components.)</li><li>A robust module system for distributing and reusing components. <br>(React is based on JavaScript which has a rich module ecosystem.)</li><li>A single specification that can work from development through production. (Adapt has some new technology for this one.)</li></ul><div class="paragraph">Let&apos;s take a quick look at how all these things work in Adapt (or you can just <a href="https://adaptjs.org/docs/getting_started/">get started</a>, no React experience required).</div><h2>Adapt </h2><div class="paragraph">All infrastructure specifications in Adapt are JavaScript programs, just like React. (Or&#xA0;<a href="https://www.typescriptlang.org/">TypeScript</a>&#xA0;programs if you prefer.) This solves all kinds of otherwise complicated problems, like:</div><ul><li>How do you define a module? </li><li>How do you version the module? </li><li>How do you distribute the module?</li></ul><div class="paragraph">Moreover, it provides all the power of a full programming language in your specifications, so you can do things like only creating infrastructure based on certain conditions, easily interacting with external APIs and services, or just about anything you can dream up. You have the full power of JavaScript and the entire&#xA0;<a href="https://npmjs.org/">NPM</a>&#xA0;library.</div><div class="paragraph">Execution of the JavaScript program results in a virtual DOM, where each element in the final DOM represents some piece of the overall infrastructure. For example, a basic&#xA0;<a href="https://nodejs.org/">Node.js</a>&#xA0;application that connects to a&#xA0;<a href="https://www.postgresql.org/">Postgres</a>&#xA0;database would look like this:</div><div class="image-container"><img src="https://hackernoon.com/photos/fhbXZwVNVDR60LZ60xY6tPkOiwE2-hl1213zey" alt></div><div class="paragraph">Just like in React, the function&#xA0;App&#xA0;is a component. Its return value is a collection of elements that represent your infrastructure, which, in this example, is at a fairly high level of abstraction. Here, all the details of how the Node.js service is built and deployed are hidden in the&#xA0;<pre><code>&lt;NodeService&gt;</code></pre>&#xA0;component. Same for&#xA0;<pre><code>&lt;Postgres&gt;</code></pre>.</div><div class="paragraph">This abstraction allows fairly simple, but powerful, specification of infrastructure and operational behavior. For example, the&#xA0;<pre><code>&lt;NodeService&gt;</code></pre>&#xA0;component could be very simple, like this:</div><div class="image-container"><img src="https://hackernoon.com/photos/fhbXZwVNVDR60LZ60xY6tPkOiwE2-0pzy3zqr" alt></div><div class="paragraph">This component will locally build the Node.js application from source code into a local&#xA0;<a href="https://www.docker.com/">Docker</a>&#xA0;image (via the&#xA0;<pre><code>&lt;LocalNodeImage&gt;</code></pre>&#xA0;component) and run that image in a local container. Here,&#xA0;<pre><code>&lt;docker.Container&gt;</code></pre>&#xA0;is a primitive element whose behavior is defined by a plugin. This is just like how the behavior of primitive elements&#xA0;<pre><code>&lt;div&gt;</code></pre>&#xA0;or&#xA0;<pre><code>&lt;p&gt;</code></pre>&#xA0;are determined by the browser. Because all primitive component behaviors are defined by plugins, Adapt can be extended to work with any infrastructure or application services that your code needs.</div><blockquote><div class="paragraph">Because all primitive component behaviors are defined by plugins, Adapt can be extended to work with any infrastructure or application services that your code needs.</div></blockquote><div class="paragraph">Fortunately, there is no need to actually write a <pre><code>&lt;NodeService&gt;</code></pre>&#xA0;component since the Adapt cloud library provides one, but as you can see, it isn&apos;t too difficult to build a custom version if you need to.</div><h2>State and Rebuilding</h2><div class="paragraph">If you&apos;re familiar with React, you know there is a lot more to React than just some clever HTML-like syntax to assemble a web page. In fact, the most powerful part of React is its state model and how it handles re-rendering a web page when state changes. Adapt has the same capability, allowing it to alter infrastructure in response to state changes, triggered by changes in the external environment, such as increased server load, a zone outage, or a push to a GitHub repository.</div><div class="paragraph">For example, in the simple&#xA0;<pre><code>&lt;NodeService&gt;</code></pre>&#xA0;component above, we really want to wait for the&#xA0;<pre><code>&lt;LocalNodeImage&gt;</code></pre>&#xA0;component to be ready before deploying the&#xA0;&lt;docker.Container&gt;. To do this, we use some state to keep track of when the&#xA0;<pre><code>&lt;LocalNodeImage&gt;</code></pre>&#xA0;is ready, and only after it is ready, render the&#xA0;<pre><code>&lt;docker.Container&gt;</code></pre>&#xA0;element. Just like with React, we can use the&#xA0;<pre><code>useState</code></pre>&#xA0;hook like this:</div><div class="image-container"><img src="https://hackernoon.com/photos/fhbXZwVNVDR60LZ60xY6tPkOiwE2-ao14j3zk8" alt></div><div class="paragraph">Of course, this is such a common operation, Adapt already provides a&#xA0;<pre><code>&lt;Sequence&gt;</code></pre>&#xA0;component to do this:</div><div class="image-container"><img src="https://hackernoon.com/photos/fhbXZwVNVDR60LZ60xY6tPkOiwE2-kh17h3zt1" alt></div><div class="paragraph">The&#xA0;<pre><code>&lt;Sequence&gt;</code></pre>&#xA0;component even deals with the tricky case where we want the&#xA0;<pre><code>&lt;docker.Container&gt;</code></pre>&#xA0;to keep running the old container until the new one is ready, along with a few other optimizations. The important thing here is how we can abstract away complex sequencing and roll out behavior using a component. Moreover,&#xA0;<pre><code>&lt;Sequence&gt;</code></pre>&#xA0;can deal with roll out and updates to any components that meet some basic interface requirements. This means that all the logic around sequenced deploys and updates are reusable.</div><div class="paragraph">As Adapt evolves, you will be able to update state based on long running observations. For example, you might be able to dynamically enable a backup availability zone if the main one has failed.</div><div class="image-container"><img src="https://hackernoon.com/photos/fhbXZwVNVDR60LZ60xY6tPkOiwE2-n61c03z98" alt></div><div class="paragraph">You would also be able to build out components that encapsulate complex functionality, like&#xA0;blue-green&#xA0;deployment, by periodically updating the state that controls how much blue you have vs. green:</div><div class="image-container"><img src="https://hackernoon.com/photos/fhbXZwVNVDR60LZ60xY6tPkOiwE2-tt1d73zty" alt></div><div class="paragraph">You could even monitor data from other applications. For example, the&#xA0;<pre><code>&lt;BlueGreen&gt;</code></pre>&#xA0;component could wait for a manual approval from a code review application before continuing to roll out more than 5% of systems with new code.</div><div class="paragraph">Of course, all this functionality and complexity would be available in a&#xA0;<pre><code>&lt;BlueGreen&gt;</code></pre> component from a library, much like&#xA0;Sequence&#xA0;in the example above, so you wouldn&apos;t have to implement complex features yourself.</div><h2><a></a><a href="http://localhost:3000/blog/2019/09/25/react-for-infrastructure#but-wait-theres-more"></a>But wait, there&apos;s more...</h2><div class="paragraph">We think that combining simple, composable, declarative specifications, along with the ability for deployments to dynamically react to their environment is already enough to make Adapt exciting and substantially different than other solutions. But there are other deployment challenges that Adapt addresses too.</div><div class="paragraph">Adapt allows you to create a single application architecture specification, then use style sheets to deploy that architecture using different underlying components for each of your environments. For example, in your&#xA0;dev&#xA0;style sheet, you can replace&#xA0;<pre><code>&lt;Postgres&gt;</code></pre>&#xA0;in the above example with a&#xA0;<pre><code>&lt;TestPostgres&gt;</code></pre>&#xA0;component that starts a Docker container and preloads some test data. Your&#xA0;prod&#xA0;style sheet replaces it with a&#xA0;<pre><code>&lt;PostgresProvider&gt;</code></pre>&#xA0;component that points to a production database that is managed outside Adapt. In a more complex application, you could even style in a custom version of Adapt&apos;s&#xA0;<pre><code>&lt;ReactApp&gt;</code></pre>&#xA0;component, which normally just deploys to a docker container, with one that builds the React application, pushes it to&#xA0;<a href="https://aws.amazon.com/s3">S3</a>&#xA0;and uses&#xA0;<a href="https://aws.amazon.com/cloudfront/">AWS cloud front</a>&#xA0;as a&#xA0;<a href="https://en.wikipedia.org/wiki/Content_delivery_network">CDN</a>.</div><blockquote><div class="paragraph">In a more complex application, you could even style in a custom version of Adapt&apos;s&#xA0;&lt;ReactApp&gt;&#xA0;component that normally just deploys to a docker container, with one that builds the React application, pushes it to S3 and uses AWS cloud front as a CDN.</div></blockquote><div class="paragraph">Of course, Adapt also deals with all the typical issues you&apos;d expect a deployment system to handle, like keeping track of each deployment&apos;s history and state, deployment logs, and as time goes on much more.</div><div class="paragraph">Our goal is to take all the difficult, repetitive, and mundane parts of deployment and make them easy...maybe even fun. That way, you can focus on delivering your application, not managing infrastructure.</div><h2><a></a><a href="http://localhost:3000/blog/2019/09/25/react-for-infrastructure#give-it-a-try"></a>Give it a try!</h2><div class="paragraph">If you want to try Adapt, head over to&#xA0;<a href="https://adaptjs.org/">adaptjs.org</a>. Don&apos;t worry, you don&apos;t need to know React to get started. There are examples and a&#xA0;<a href="https://adaptjs.org/docs/getting_started/">getting started guide</a>&#xA0;that will have you up and running with your first application in under 5 minutes.</div>                    <h2 class="tags-header">Tags</h2>          <div class="archive-tags">                                                <a class="tag" href="https://hackernoon.com/tagged/react">React</a>                                                <a class="tag" href="https://hackernoon.com/tagged/reactjs">Reactjs</a>                                                <a class="tag" href="https://hackernoon.com/tagged/devops">Devops</a>                                                <a class="tag" href="https://hackernoon.com/tagged/javascript">Javascript</a>                                                <a class="tag" href="https://hackernoon.com/tagged/nodejs">Nodejs</a>                                                <a class="tag" href="https://hackernoon.com/tagged/software-development">Software Development</a>                                                <a class="tag" href="https://hackernoon.com/tagged/programming">Programming</a>                                                <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                      </div>                                        <div class="twitter-discussion">            <a target="_blank" href="https://community.hackernoon.com/t/14026">Continue the Discussion <i class="fas fa-comments-alt"></i></a>          </div>