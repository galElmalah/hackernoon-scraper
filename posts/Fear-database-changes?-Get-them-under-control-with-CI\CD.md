<img src="https://hackernoon.com/drafts/f47va2gze.png">                              <div class="paragraph">Developers often fear database changes because a mistake by anyone on your team can lead to a major outage and even data loss. The stakes are higher when changes are not backwards compatible, cannot be rolled back, or impact system performance. This can cause a lack of confidence and slow your team velocity. As a result, database changes are a common failure point in agile and DevOps.&#xA0;</div><div class="paragraph">Databases are often created created manually and too often evolve through manual changes, informal process, and even testing in production. Manual changes often lack documentation and are harder to review, test, and coordinate with software releases. This makes your system more fragile with a higher risk of failure.</div><div class="paragraph">The solution is to include your database in your source control and CI/CD pipeline. This lets your team document each change, follow the code review process, test it thoroughly before release, make rollbacks easier, and coordinate with software releases.</div><div class="paragraph">Let&#x2019;s look at an example of how you can include your database in your CI/CD process and how to push a non-backwards-compatible database change successfully. We&apos;ll also look at testing your changes, progressive deployments, dealing with rollbacks, issues to look out for, and a few helpful tools.</div><h2><strong>What is CI/CD?</strong></h2><div class="paragraph">CI/CD is a cornerstone of modern development and DevOps.&#xA0;</div><div class="paragraph">CI&#x2014;or Continuous Integration&#x2014;is the practice of merging all working developer code into a shared repository throughout the day. Its purpose is to prevent integration problems by integrating often and early. Commonly, this integration kicks off an automated build and test.</div><div class="paragraph">CD&#x2014;or Continuous Delivery&#x2014;is the practice of building, testing, and releasing software in short cycles, with the aim of ensuring that a working version of the software can be released at any time.</div><h2><strong>Is Your Database Ready For CI/CD?</strong></h2><div class="paragraph">There are several key requirements to having your database ready for CI/CD. First, the database must be reproducible from scratch using one or more SQL scripts. This means that in addition to a script that creates the initial version of your database, you must also maintain scripts that make all required schema updates to your database.</div><div class="paragraph">When you create these scripts, you have two options:</div><ol><li>Create one script per schema object, then update the corresponding script (state based) when making changes to the object.</li><li>Create one original script that creates the entire database schema. Then, create a series of individual change scripts (migration based) for changes.</li></ol><div class="paragraph">To learn more, check out <a href="https://dev.to/pesse/one-does-not-simply-update-a-database--migration-based-database-development-527d">this excellent article</a> on state-based versus migration-based database updates.</div><div class="paragraph">The second requirement for CI/CD is that the database schema (meaning, those scripts we just mentioned), just like your source code, must live in source control. You must treat your database schema changes as a controlled process just as you do with code.&#xA0;</div><div class="paragraph">Third, always back up before performing any database migrations. If you&apos;re working with a live production database, consider a <a href="https://devcenter.heroku.com/articles/heroku-postgres-follower-databases">Postgres follower database</a> for your migration or upgrade.&#xA0;</div><div class="paragraph">Lastly, changes that involve removing a database object, such as deleting a column as shown below, can be more difficult to deal with due to the loss of data. Many organizations develop strategies to deal with this, such as only allowing additive changes (e.g. adding a column), or having a team of DBAs that deals with such changes.&#xA0;</div><h2><strong>Is Your Team Ready for CI/CD?</strong></h2><div class="paragraph">Perhaps the best process for database changes and database CI/CD is ensuring you have a collaborative effort between DevOps and DBAs. Make sure your DBAs are part of the code review cycle; they can help to identify issues that only they may know about. DBAs have knowledge of the databases in each specific environment, including database specific dependencies such as ETL load jobs, database maintenance tasks, and more.</div><div class="paragraph">Be sure to consult a database SME in setting up your database for CI/CD, and in any migration process, when possible. Be sure to also follow sensible DevOps processes, such as test your changes in a test environment, performing backups, mitigating risks, being prepared for rollbacks, and so on.</div><h2><strong>How Your CI Tool Helps With Migrations</strong></h2><div class="paragraph">When you create or update these scripts, and push them to source control, your CI tool (such as Jenkins or Heroku CI) will pull the changes and then:</div><ol><li>Rebuild your database to the newest version of the scripts in a test or staging environment. Since the database is being rebuilt, be sure to export the look up/reference data, then import it back to the new schema. Although it is possible to export and import transactional data, transactional data is out of scope for this article. You can <a href="https://www.isaca.org/Journal/archives/2012/Volume-1/Pages/Database-Backup-and-Recovery-Best-Practices.aspx">read more about best practices here</a> if interested.</li><li>Run your tests. For testing your database changes, one possible time saver is to have two sets of tests. The first set is a quick test that verifies your build scripts and runs a few basic functional tests (such as referential integrity, stored procedures unit tests, triggers, and so on). The second set includes migration of transactional data (possibly scrubbed production data) to run a more realistic full set of tests.</li><li>Deploy your database changes to your production environment or another selected environment. (Depending on your migration strategy, the CI tool should also simultaneously deploy and test any code changes dependent on the database change.)</li></ol><h2><strong>Watch Out for These Common Problems</strong></h2><div class="paragraph">In many cases, when you&apos;re making a simple schema addition with bidirectionally compatible code, then you can push code and database changes at the same time. This shouldn&apos;t be an issue, as rollbacks in our case will be easy and predictable. This is often true when we are dealing with microservices with simple database components.</div><div class="paragraph">However, in many scenarios, serious problems can happen with this simplistic approach:</div><ul><li>Production data may be different from test/stage data and cause unforeseen issues.A</li><li> large number of changes in both code and database schema may be in the pipeline and need to be deployed simultaneously.</li><li>CI/CD processes may not be consistent through every environment.</li><li>You may be under a zero-downtime mandate.</li><li>Even using tools that help you to achieve zero-downtime (such as Heroku preboot) you can end up with two versions of the code running simultaneously.</li></ul><div class="paragraph">There are several strategies for addressing the above issues. Some popular solutions include:</div><ul><li>If your changes are backwards-compatible, then use a tick-tock release pattern. This approach involves releasing the new database column then releasing the new code. You can identify problems early in this manner, with minimal production changes. Additionally, the rollback remains small and manageable, and can be accomplished with tools such as Heroku&apos;s Postgres rollback, as noted above.</li><li>If your provider supports it, use a blue/green rollout. In this pattern, an entirely new set of production servers is created side-by-side with the current production servers. Enable database synchronization and use a DNS or a proxyto cut over to the new servers/database. You can rollback by simply changing the proxy back to the original servers.</li></ul><h2><strong>A Simple Migration Example</strong></h2><div class="paragraph">Let&#x2019;s run through an example based on the the migration scripting option as explained above. Note that some frameworks (Rails, Django, ORM tools, and so on) abstract out or handle schema creation and migration for you. While the details may differ according to the framework you are using, the below example should still help you to understand these core concepts. For example, you may have a schema configuration file to include in your CI/CD process.</div><div class="paragraph">For our example, we&apos;ll use Node.js, Postgres, and GitHub. We&apos;ll also use Heroku because it provides convenient tools including <a href="https://devcenter.heroku.com/articles/heroku-ci">Heroku CI</a> with deploy scripts for CI/CD, and easy Postgres rollbacks in case we make a mistake. If you need help deploying Node.js and Postgres on Heroku, <a href="https://devcenter.heroku.com/articles/getting-started-with-nodejs?singlepage=true">here&#x2019;s a quick walk-through</a>.</div><div class="paragraph">Here&apos;s the pertinent code for our example. We&apos;re going to create a simple database with a single table, and a Node.js file that writes to that database table on load.&#xA0;</div><div class="paragraph">Database creation SQL (we have just one simple table):</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code><span style="color:#c397d8">CREATE</span> <span style="color:#c397d8">TABLE</span> <span style="color:#c397d8">users</span> (&#xA0; &#xA0;<span style="color:#c397d8">id</span> &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; <span style="color:#e78c45">integer</span> PRIMARY <span style="color:#c397d8">KEY</span>,&#xA0; &#xA0;firstname &#xA0; &#xA0;<span style="color:#e78c45">varchar</span>(<span style="color:#e78c45">40</span>) <span style="color:#c397d8">NOT</span> <span style="color:#e78c45">NULL</span>,&#xA0; &#xA0;lastname &#xA0; &#xA0; <span style="color:#e78c45">varchar</span>(<span style="color:#e78c45">40</span>) <span style="color:#c397d8">NOT</span> <span style="color:#e78c45">NULL</span>,&#xA0; &#xA0;enrolled &#xA0; &#xA0; <span style="color:#e78c45">char</span>(<span style="color:#e78c45">1</span>) <span style="color:#c397d8">NOT</span> <span style="color:#e78c45">NULL</span>,&#xA0; &#xA0;created_at &#xA0; <span style="color:#e78c45">date</span> <span style="color:#c397d8">NOT</span> <span style="color:#e78c45">NULL</span>);</code></pre></div><div class="paragraph">Node.js</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code><span style="color:#c397d8">const</span> result = <span style="color:#c397d8">await</span> client.query(<span style="color:#b9ca4a">&apos;INSERT INTO users&#xA0;&#xA0; (id,firstname,lastname,enrolled,created_at)&#xA0;&#xA0; values ($1,$2,$3,$4,$5) &apos;</span>,[<span style="color:#e78c45">1</span>,<span style="color:#b9ca4a">&apos;Becky&apos;</span>,<span style="color:#b9ca4a">&apos;Smith&apos;</span>,<span style="color:#b9ca4a">&apos;y&apos;</span>,<span style="color:#c397d8">new</span> <span style="color:#e78c45">Date</span>()]);</code></pre></div><div class="paragraph">Once these files are checked into GitHub and our repository is attached to a Heroku app, we can enable the <a href="https://devcenter.heroku.com/articles/heroku-ci">Heroku CI tool</a> on the Heroku dashboard:</div><div class="image-container"><img src="https://hackernoon.com/photos/XnOdQ9ymHwTqEaXbwoUc7yrZKIu2-4j22gwy" alt></div><div class="paragraph">The real work is done by the <a href="https://devcenter.heroku.com/articles/procfile">Heroku Procfile</a> and the <a href="https://devcenter.heroku.com/articles/release-phase">Heroku release phase</a>. Using those, we can tell the Heroku CI tool to run a database migration SQL file any time a new release is created (in other words, a successful compile). Here is the release line we need to include in the Heroku Procfile:</div><div class="paragraph"><pre><code>release: bash ./release-tasks.sh</code></pre></div><div class="paragraph">The content of the release-tasks file includes a list of SQL scripts to run. That list is updated with each release to include the needed schema modifications. For this very simple example, it will point to just one script:</div><div class="paragraph"><pre><code>psql -h &lt;hostname&gt; -d &lt;database&gt; -U &lt;user&gt; -w -f database/migrate.sql</code></pre></div><div class="paragraph">(The database password can be supplied as a Heroku environment variable.)</div><div class="paragraph">Typically, as we are using the migration-based strategy, we would add additional migration scripts for each set of changes. For a more robust solution, we could use a tool such as Liquibase, <a href="https://pypi.org/project/alembic/">Alembic</a> or <a href="https://flywaydb.org/">Flyway.</a> These tools add version control to your database, both generating the necessary change scripts between releases, and giving you the ability to easily roll back changes. For example, Flyaway creates scripts that allow you to migrate from any version of your database (including an empty database) to the latest version of the schema.</div><div class="paragraph">To kick off the CI tool, we make two changes: drop a required column, and change the JavaScript to no longer reference that column. First, we update the SQL code in Node.js,&#xA0;taking out the column:</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code><span style="color:#c397d8">const</span> result = <span style="color:#c397d8">await</span> client.query(<span style="color:#b9ca4a">&apos;INSERT INTO users&#xA0;&#xA0; (id,firstname,lastname,created_at)&#xA0;&#xA0; values ($1,$2,$3,$4) &apos;</span>,[<span style="color:#e78c45">2</span>,<span style="color:#b9ca4a">&apos;Becky&apos;</span>,<span style="color:#b9ca4a">&apos;Smith&apos;</span>,<span style="color:#c397d8">new</span> <span style="color:#e78c45">Date</span>()]);</code></pre></div><div class="paragraph">Next, we create a migrate.sql file (referenced in the Procfile above) to alter the table and remove the column:</div><div class="code-container"><pre style="display:block;overflow-x:auto;background:black;color:#eaeaea;padding:30px"><code><span style="color:#c397d8">ALTER</span> <span style="color:#c397d8">TABLE</span> <span style="color:#c397d8">users</span> <span style="color:#c397d8">DROP</span> <span style="color:#c397d8">COLUMN</span> enrolled;</code></pre></div><div class="paragraph">Now, we commit the code change and SQL file, and watch the CI magic. First, the integration tests run. If you are using a common testing framework, the Heroku CI tool probably works with your test suite.&#xA0;</div><div class="image-container"><img src="https://hackernoon.com/photos/XnOdQ9ymHwTqEaXbwoUc7yrZKIu2-ef46n2gos" alt></div><div class="paragraph">And now the CI tool creates a new release and deploys the app, which kicks off the migrate.sql file. (See the middle of the image below.)</div><div class="image-container"><img src="https://hackernoon.com/photos/XnOdQ9ymHwTqEaXbwoUc7yrZKIu2-5y4el2ggw" alt></div><div class="paragraph">We can check to see that the column was removed by inspecting the database through the Heroku CLI tool:</div><div class="image-container"><img src="https://hackernoon.com/photos/XnOdQ9ymHwTqEaXbwoUc7yrZKIu2-n14g12gvz" alt></div><div class="paragraph">It worked! There is no longer a column named &apos;enrolled&apos;. Our CI tool ran our script and deleted the column.</div><div class="paragraph">Some tools, like Liquibase, keep a detailed list of database changes. These tools allow you to easily see the last set of changes in cases like the above.</div><div class="paragraph">Now, any time that code or an updated migrate.sql is committed in the future, the CI tool will kick off the tests. If the tests pass, this creates a new release and pushes it to staging. When there is a new release, the migrate.sql file runs against the staging database.</div><div class="paragraph">We&apos;ve taken a simple route here for demonstration purposes, but could have made this process more robust. For instance, when moving a new release to staging, we could wipe out the old version of the database, create a new one from scratch running the original creation script plus all migration scripts, and then populate the database with any reference data all through the Procfile and release phase.&#xA0;Also note that for simplicity sake, we are not running this migration with transactions in progress. In a real-world scenario, <a href="https://devcenter.heroku.com/articles/release-phase#review-apps-and-the-postdeploy-script">Heroku recommends using an advisory lock</a> to prevent concurrent migrations.</div><h2><strong>How To Do Rollbacks</strong></h2><div class="paragraph">Even with the best planning and forethought, there will be times when you need to roll back your database. There are many approaches to rolling back failed deployments.</div><ul><li>Create a SQL file that rolls back the changes quickly. (For example, while you are in staging, use a compare utility to generate the script.) This file should be part of the deployment package so that you can quickly run the rollback if there is an error.</li><li>Roll forward (quickly push a new build that fixes the issue).</li><li>Rely on source control and labels or branches to recreate and deploy the previous version.</li><li>Restore a full backup of your database. (Use a tool that ships with your database, such as pg_restore in Postgres.)</li><li>Use a tool provided by your platform, such as <a href="https://devcenter.heroku.com/articles/heroku-postgres-rollback">Heroku Postgres Rollback</a> and <a href="https://devcenter.heroku.com/articles/releases#rollback">Heroku Release Rollback</a> for code. As the name implies, Heroku Postgres Rollback allows you to easily roll back your database to a previous point in time, quickly and confidently moving your database back to a working release.</li></ul><div class="paragraph">Be aware that all these solutions come with their own challenges, such as potential loss of new data (restoring a backup or redeploying) and introducing new bugs.</div><h2><strong>Summary</strong></h2><div class="paragraph">Database changes and migrations can be scary, and can cause serious mistrust. However, if you place your database under CI/CD controls, you can not only confidently migrate your changes, but also move towards a better agile and DevOps experience. This is can be as simple as using source control for your database schema, having a good process in place with your DevOps and DBA teams, and using your existing CI tools to test and migrate your databases. Once you establish and train your team on the new process, future changes will be smoother and more automatic than your old manual process.<br><br></div>                    <h2 class="tags-header">Tags</h2>          <div class="archive-tags">                                                <a class="tag" href="https://hackernoon.com/tagged/databases">Databases</a>                                                <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                                                <a class="tag" href="https://hackernoon.com/tagged/software-development">Software Development</a>                                                <a class="tag" href="https://hackernoon.com/tagged/sql">Sql</a>                                                <a class="tag" href="https://hackernoon.com/tagged/cicd">Cicd</a>                                                <a class="tag" href="https://hackernoon.com/tagged/continuous-integration">Continuous Integration</a>                                                <a class="tag" href="https://hackernoon.com/tagged/heroku">Heroku</a>                                                <a class="tag" href="https://hackernoon.com/tagged/hackernoon-top-story">Hackernoon Top Story</a>                      </div>                                        <div class="twitter-discussion">            <a target="_blank" href="https://community.hackernoon.com/t/21474">Continue the Discussion <i class="fas fa-comments-alt"></i></a>          </div>