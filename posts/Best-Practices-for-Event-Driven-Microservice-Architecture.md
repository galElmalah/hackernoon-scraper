<img src="https://hackernoon.com/drafts/641v21y4.png">                    <div class="paragraph">If you&#x2019;re an enterprise architect, you&#x2019;ve probably heard of and worked with a microservices architecture. And while you might have used REST as your service communications layer in the past, more and more projects are moving to an event-driven architecture. Let&#x2019;s dive into the pros and cons of this popular architecture, some of the key design choices it entails, and common anti-patterns.</div><h2>What is Event-Driven Microservice Architecture?</h2><div class="paragraph">In event-driven architecture, when a service performs some piece of work that other services might be interested in, that service produces an <em>event</em>&#x2014;a record of the performed action. Other services consume those events so that they can perform any of their own tasks needed as a result of the event. Unlike with REST, services that create requests do not need to know the details of the services consuming the requests.&#xA0;</div><div class="paragraph">Here&#x2019;s a simple example: When an order is placed on an ecommerce site, a single &#x201C;order placed&#x201D; event is produced and then consumed by several microservices:</div><ol><li> the order service which could write an <em>order</em> record to the database</li><li>the customer service which could create the <em>customer</em> record, and </li><li>the payment service which could process the payment.&#xA0;</li></ol><div class="paragraph">Events can be published in a variety of ways. For example, they can be published to a queue that guarantees delivery of the event to the appropriate consumers, or they can be published to a &#x201C;pub/sub&#x201D; model stream that publishes the event and allows access to all interested parties. In either case, the <em>producer </em>publishes the event, and the <em>consumer </em>receives that event, reacting accordingly. Note that in some cases, these two actors can also be called the <em>publisher </em>(the producer) and the <em>subscriber </em>(the consumer).</div><h2>Why Use Event-Driven Architecture</h2><div class="paragraph">An event-driven architecture offers several advantages over REST, which include:</div><ul><li><strong>Asynchronous</strong> &#x2013; event-based architectures are asynchronous without blocking. This allows resources to move freely to the next task once their unit of work is complete, without worrying about what happened before or will happen next. They also allow events to be queued or buffered which prevents consumers from putting back pressure on producers or blocking them.</li><li><strong>Loose Coupling</strong> &#x2013; services don&#x2019;t need (and shouldn&#x2019;t have) knowledge of, or dependencies on other services. When using events, services operate independently, without knowledge of other services, including their implementation details and transport protocol. Services under an event model can be updated, tested, and deployed independently and more easily.</li><li><strong>Easy Scaling</strong> &#x2013; Since the services are decoupled under an event-driven architecture, and as services typically perform only one task, tracking down bottlenecks to a specific service, and scaling that service (and only that service) becomes easy.</li><li>R<strong>ecovery support</strong> &#x2013; An event-driven architecture with a queue can recover lost work by &#x201C;replaying&#x201D; events from the past. This can be valuable to prevent data loss when a consumer needs to recover.</li></ul><div class="paragraph">Of course, event-driven architectures have drawbacks as well. They are easy to over-engineer by separating concerns that might be simpler when closely coupled;&#xA0; can require a significant upfront investment;  and often result in additional complexity in infrastructure, service contracts or schemas, polyglot build systems, and dependency graphs.&#xA0;</div><div class="paragraph">Perhaps the most significant drawback and challenge is data and transaction management. Because of their asynchronous nature, event-driven models must carefully handle inconsistent data between services, incompatible versions, watch for duplicate events, and typically do not support ACID transactions, instead supporting <a href="https://en.wikipedia.org/wiki/Eventual_consistency">eventual consistency</a> which can be more difficult to track or debug.</div><div class="paragraph">Even with these drawbacks, an event-driven architecture is usually the better choice for enterprise-level microservice systems. The pros&#x2014;scalable, loosely coupled, dev-ops friendly design&#x2014;outweigh the cons.&#xA0;</div><h2>When to Use REST</h2><div class="paragraph">There are, however, times when a REST/web interface may still be preferable:</div><ul><li>You need a time-bound request/reply interface</li><li>Convenient support for transactions</li><li>Your API is available to the public</li><li>Your project is small (REST is much simpler to set up and deploy)</li></ul><h2>Your Most Important Design Choice &#x2013; Messaging Framework</h2><div class="paragraph">Once you&#x2019;ve decided on an event-driven architecture, it is time to choose your event framework. The way your events are produced and consumed is a key factor in your system. Dozens of proven frameworks and choices exist and choosing the right one takes time and research.</div><div class="paragraph">Your basic choice comes down to message processing or stream processing.</div><div class="paragraph"><strong>Message Processing&#xA0;</strong></div><div class="paragraph">In traditional message processing, a component creates a message then sends it to a specific (and typically single) destination. The receiving component, which has been sitting idle and waiting, receives the message and acts accordingly. Typically, when the message arrives, the receiving component performs a single process. Then,&#xA0; the message is deleted.</div><div class="paragraph">A typical example of a message processing architecture is a Message Queue. Though most newer projects use stream processing (as described below), architectures using message (or event) queues are still popular. Message queues typically use a &#x201C;store and forward&#x201D; system of brokers where events travel from broker to broker until they reach the appropriate consumer.<a href="https://activemq.apache.org/"> ActiveMQ</a> and<a href="https://www.rabbitmq.com/"> RabbitMQ</a> are two popular examples of message queue frameworks. Both of these projects have years of proven use and established communities.</div><div class="paragraph"><strong>Stream Processing</strong></div><div class="paragraph">On the other hand, in stream processing, components emit events when they reach a certain state. Other interested components listen for these events on the event stream and react accordingly. Events are not targeted to a certain recipient, but rather are available to all interested components.</div><div class="paragraph">In stream processing, components can react to multiple events at the same time, and apply complex operations on multiple streams and events. Some streams include persistence where events stay on the stream for as long as necessary.</div><div class="paragraph">With stream processing, a system can reproduce a history of events, come online after the event occurred and still react to it, and even perform sliding window computations. For example, it could calculate the average CPU usage per minute from a stream of per-second events.</div><div class="paragraph">One of the most popular stream processing frameworks is<a href="https://kafka.apache.org/"> Apache Kafka</a>. Kafka is a mature and stable solution used by many projects. It can be considered a go-to, industrial-strength stream processing solution. Kafka has a large userbase, a helpful community, and an evolved toolset.</div><div class="paragraph"><strong>Other Choices</strong></div><div class="paragraph">There are other frameworks that offer either a combination of stream and message processing or their own unique solution. For example,<a href="https://pulsar.apache.org/"> Pulsar</a>, a newer offering from Apache, is an open-source pub/sub messaging system that supports both streams and event queues, all with extremely high performance. Pulsar is feature-rich&#x2014;it offers multi-tenancy and geo-replication&#x2014;and accordingly complex. It&#x2019;s been said that Kafka aims for high throughput, while Pulsar aims for low latency.</div><div class="paragraph"><a href="https://nats.io/">NATS</a> is an alternative pub/sub messaging system with &#x201C;synthetic&#x201D; queueing. NATS is designed for sending small, frequent messages. It offers both high performance and low latency. However, NATS considers some level of data loss to be acceptable, prioritizing performance over delivery guarantees.</div><h2>Other Design Considerations</h2><div class="paragraph">Once you&#x2019;ve selected your event framework, here are several other challenges to consider:&#xA0;</div><div class="paragraph"><strong>Event Sourcing</strong></div><div class="paragraph">It is difficult to implement a combination of loosely-coupled services, distinct data stores, and atomic transactions. One pattern that may help is<a href="https://martinfowler.com/eaaDev/EventSourcing.html"> Event Sourcing</a>. In Event Sourcing, updates and deletes are never performed directly on the data; rather, state changes of an entity are saved as a series of events.</div><div class="paragraph"><strong>CQRS</strong></div><div class="paragraph">The above event sourcing introduces another issue: Since state needs to be built from a series of events, queries can be slow and complex.<a href="https://www.martinfowler.com/bliki/CQRS.html"> </a>Command Query Responsibility Segregation (<a href="https://www.martinfowler.com/bliki/CQRS.html">CQRS</a>) is a design solution that calls for separate models for insert operations and read operations.</div><div class="paragraph"><strong>Discovering Event Information</strong></div><div class="paragraph">One of the greatest challenges in event-driven architecture is cataloging services and events. Where do you find event descriptions and details? What is the reason for an event? What team created the event? Are they actively working on it?&#xA0;</div><div class="paragraph"><strong>Dealing with Change</strong></div><div class="paragraph">Will an event schema change? How do you change an event schema without breaking other services? How you answer these questions becomes&#xA0; critical as your number of services and events grows. <br><br>Being a good event consumer means coding for schemas that change. Being a good event producer means being cognizant of how your schema changes impact other services and creating well-designed events that are documented clearly.</div><div class="paragraph"><strong>On Premise vs Hosted Deployment</strong></div><div class="paragraph">Regardless of your event framework, you&#x2019;ll also need to decide between deploying the framework yourself on premise (message brokers are not trivial to operate, especially with high availability), or using a hosted service such as <a href="https://www.heroku.com/kafka">Apache Kafka on Heroku</a>.</div><h2>Anti-Patterns</h2><div class="paragraph">As with most architectures, an event-driven architecture comes with its own set of anti-patterns. Here are a few to watch out for.</div><div class="paragraph"><strong>Too much of a good thing</strong></div><div class="paragraph">Be careful you don&#x2019;t get too excited about creating events. Creating too many events will create unnecessary complexity between the services, increase cognitive load for developers, make deployment and testing more difficult, and cause congestion for event consumers. Not every method needs to be an event.&#xA0;</div><div class="paragraph"><strong>Generic events</strong></div><div class="paragraph">Don&#x2019;t use generic events, either in name or in purpose. You want other teams to understand why your event exists, what it should be used for, and when it should be used. Events should have a specific purpose and be named accordingly. Events with generic names, or generic events with confusing flags, cause issues.</div><div class="paragraph"><strong>Complex dependency graphs</strong></div><div class="paragraph">Watch out for services that depend on one another and create complex dependency graphs or feedback loops. Each network hop adds additional latency to the original request, particularly north/south network traffic that leaves the datacenter.<br></div><div class="paragraph"><strong>Depending on guaranteed order, delivery, or side effects&#xA0;</strong></div><div class="paragraph">Events are asynchronous; therefore, including assumptions of order or duplicates will not only add complexity but will negate many of the key benefits of event-based architecture. If your consumer has side effects, such as adding a value in a database, then you may be unable to recover by replaying events.</div><div class="paragraph"><strong>Premature optimization</strong></div><div class="paragraph">Most products start off small and grow over time. While you may dream of future needs to scale to a large complex organization, if your team is small then the added complexity of event-driven architectures may actually slow you down. Instead, consider designing your system with a simple architecture but include the necessary separation of concerns so that you can swap it out as your needs grow.</div><div class="paragraph"><strong>Expecting event-driven to fix everything</strong></div><div class="paragraph">On a less technical level, don&#x2019;t expect event-driven architecture to fix all your problems. While this architecture can certainly improve many areas of technical dysfunction, it can&#x2019;t fix core problems such as a lack of automated testing, poor team communication, or outdated dev-ops practices.</div><h2>Learn More&#xA0;</h2><div class="paragraph">Understanding the pros and cons of event-driven architectures, and some of their most common design decisions and challenges is an important part of creating the best design possible.&#xA0;</div><div class="paragraph">If you want to learn more, check out this <a href="https://devcenter.heroku.com/articles/event-driven-microservices-with-apache-kafka">event-driven reference architecture</a> we made at Heroku, which allows you to deploy a working project on Heroku with a single click. This reference architecture creates a web store selling fictional coffee products.</div><div class="image-container"><img src="https://hackernoon.com/photos/XnOdQ9ymHwTqEaXbwoUc7yrZKIu2-y0221j3" alt></div><div class="paragraph">Product clicks are tracked as events and stored in Kafka. Then, they are consumed by a reporting dashboard.&#xA0;</div><div class="image-container"><img src="https://hackernoon.com/photos/XnOdQ9ymHwTqEaXbwoUc7yrZKIu2-fc9921f2" alt></div><div class="paragraph">The code is open source so you can modify it according to your needs and run your own experiments.</div>                    <h2 class="tags-header">Tags</h2>          <div class="archive-tags">                                                <a class="tag" href="https://hackernoon.com/tagged/microservices">Microservices</a>                                                <a class="tag" href="https://hackernoon.com/tagged/architecture">Architecture</a>                                                <a class="tag" href="https://hackernoon.com/tagged/event-driven">Event Driven</a>                                                <a class="tag" href="https://hackernoon.com/tagged/software-development">Software Development</a>                                                <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                                                <a class="tag" href="https://hackernoon.com/tagged/programming">Programming</a>                                                <a class="tag" href="https://hackernoon.com/tagged/event-driven-microservice-architecture">Event Driven Microservice Architecture</a>                                                <a class="tag" href="https://hackernoon.com/tagged/hackernoon-top-story">Hackernoon Top Story</a>                      </div>                              <div class="divider-title comments">            <div class="divider"></div>            <h1 class="more-heading">Comments</h1>            <div class="divider"></div>          </div>          <div class="comments">                                                            <div class="comment">              <div class="bio">                <div class="avatar" style="width:40px;height:40px;background-image: url(&apos;https://community.hackernoon.com/user_avatar/community.hackernoon.com/VictorGil/90/10_2.png&apos;)"></div>                <div class="name"><a href="/@VictorGil">VictorGil</a></div>                <div class="spacer"></div>                <div class="date">September 19th, 2019</div>              </div>              <div class="message">                <p>Very comprehensive article.<br>Regarding streams-based event-driven microservices using Kafka, I would just add that it enables local materialized views which allows you to keep the application state close to the services with no hassles, you may check <a href="https://dev.to/victorgil/using-apache-kafka-to-implement-event-driven-microservices-af2" rel="nofollow noopener"><strong>my post</strong></a>.</p>              </div>            </div>                                                <div class="comment">              <div class="bio">                <div class="avatar" style="width:40px;height:40px;background-image: url(&apos;https://community.hackernoon.com/user_avatar/community.hackernoon.com/maxim/90/10_2.png&apos;)"></div>                <div class="name"><a href="/@maxim">maxim</a></div>                <div class="spacer"></div>                <div class="date">September 21st, 2019</div>              </div>              <div class="message">                <p>I would add <strong>orchestration</strong> as another approach to event-driven service architecture. In the large set of use cases it is much better fit than choreography described in this article. Look at the example of the beginning of the article:</p><ol><li>the order service which could write an  <em>order</em>  record to the database</li><li>the customer service which could create the  <em>customer</em>  record, and</li><li>the payment service which could process the payment.</li></ol><p>A real application  would never create payment, customer and order records based on a single message as the above three services have to coordinate between them to achieve the business objective. For example the payment should be processed only after the order is shipped and not processed if there is not enough inventory. Orchestration solves this problem much cleaner as it allows to specify the whole business transaction is a centralized component.</p><p>I would recommend to look at the <a href="https://cadenceworkflow.io/" rel="nofollow noopener">Cadence Workflow</a> which is an open source developer friendly orchestrator developed by Uber. For example it is used to process tip requests in Uber application.</p><p><em>Disclamer</em>: I&#x2019;m tech lead of the Cadence project.</p>              </div>            </div>                                                <div class="comment">              <div class="bio">                <div class="avatar" style="width:40px;height:40px;background-image: url(&apos;https://community.hackernoon.com/user_avatar/community.hackernoon.com/fmvilas/90/10_2.png&apos;)"></div>                <div class="name"><a href="/@fmvilas">fmvilas</a></div>                <div class="spacer"></div>                <div class="date">September 30th, 2019</div>              </div>              <div class="message">                <p>Great article, Jason. I enjoyed reading it.</p><p>I&#x2019;d add that now it&#x2019;s possible to have your event-driven architecture documented with <a href="https://www.asyncapi.com" rel="nofollow noopener">AsyncAPI</a>. <em>Disclaimer: I&#x2019;m the AsyncAPI creator.</em></p>              </div>            </div>                                                <div class="comment">              <div class="bio">                <div class="avatar" style="width:40px;height:40px;background-image: url(&apos;https://community.hackernoon.com/user_avatar/community.hackernoon.com/ziv-salzman/90/10_2.png&apos;)"></div>                <div class="name"><a href="/@ziv-salzman">ziv-salzman</a></div>                <div class="spacer"></div>                <div class="date">November 8th, 2019</div>              </div>              <div class="message">                <p>Thanks for sharing this a great article. I&#x2019;ve recently started <a href="https://kalium.alkal.io" rel="nofollow noopener">https://kalium.alkal.io</a><br>Kalium provides an easy to use api for creating event driven architecture on top of Kafka. Currently, built for JVM and support handling of pojos and protobuf.<br>I&#x2019;ll be more than happy to get your feedback.</p>              </div>            </div>                                                <div class="comment">              <div class="bio">                <div class="avatar" style="width:40px;height:40px;background-image: url(&apos;https://community.hackernoon.com/user_avatar/community.hackernoon.com/VictorGil/90/10_2.png&apos;)"></div>                <div class="name"><a href="/@VictorGil">VictorGil</a></div>                <div class="spacer"></div>                <div class="date">November 12th, 2019</div>              </div>              <div class="message">                <p>Maxim, I recently discovered Cadence and it looks very interesting, I watched the video of the talk you gave back in 2017 when you just open-sourced it.<br>I plan to (partially) rewrite my PoC event-driven microservice application (which is currently implemented using Kafka) in order to use Cadence instead, I think it will be a good learning exercise and after that I will of course blog about it, of course <img src="/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"><br>After having played with it, if I am satisfied, I may push for Cadence at work (I work for a major European financial organization and currently we are looking into new technologies to replace our legacy stack).<br>Quick question if I may: as I understood it, Cadence (as the orchestrator) talks to every single one of the microservices, and each of the microservices talks only to Cadence, correct?<br>Doesn&#x2019;t that introduce a single point of failure? Thanks in advance and keep up the good work!</p>              </div>            </div>                                                <div class="comment">              <div class="bio">                <div class="avatar" style="width:40px;height:40px;background-image: url(&apos;https://community.hackernoon.com/user_avatar/community.hackernoon.com/maxim/90/10_2.png&apos;)"></div>                <div class="name"><a href="/@maxim">maxim</a></div>                <div class="spacer"></div>                <div class="date">November 13th, 2019</div>              </div>              <div class="message">                <p>Victor, thanks for looking into Cadence!<br>Cadence is indeed the single point of failure of such systems as all the components interact through it. The solution is not having a single point of failure inside the Cadence itself. Each Cadence cluster is highly available and able to sustain multiple host failures without availability loss. It also runs on a replicated database store which is immune to host failures.<br>Obviously this is not enough as there are failure modes like bad database schema deployment or just full region power outage that can bring the whole cluster down. For these situations Cadence provides<a href="https://cadenceworkflow.io/docs/10_cross_dc" rel="nofollow noopener">cross-cluster</a> asynchronous replication.  With cross-cluster each workflow gets replicated to more than one Cadence cluster usually in different regions (using AWS terminology). This allows to keep system up and running even in the case of complete region or Cadence cluster outages.<br>This setup was considered reliable enough for Uber to bet on it for dozens of business critical use cases. For example when the &#x201C;tip driver&#x201D; button in the Uber app is pressed a Cadence workflow is started.</p><p>Feel free to join the <a href="https://join.slack.com/t/uber-cadence/shared_invite/enQtNDczNTgxMjYxNDEzLTQyYjcxZDM2YTIxMTZkMzQ0NjgxYmI3OWY5ODhiOTliM2I5MzA4NTM4MjU4YzgzZDkwNGEzOTUzNTBlNDk3Yjc" rel="nofollow noopener">Cadence Slack Channel</a> to discuss.</p>              </div>            </div>                                                <div class="comment">              <div class="bio">                <div class="avatar" style="width:40px;height:40px;background-image: url(&apos;https://community.hackernoon.com/user_avatar/community.hackernoon.com/VictorGil/90/10_2.png&apos;)"></div>                <div class="name"><a href="/@VictorGil">VictorGil</a></div>                <div class="spacer"></div>                <div class="date">November 13th, 2019</div>              </div>              <div class="message">                <p>Thanks so much for such a detailed answer! I have just joined the Cadence Slack, once I finish my initial research I will post any questions which may arise there.</p>              </div>            </div>                                  </div>                              <div class="twitter-discussion">            <a target="_blank" href="https://community.hackernoon.com/t/13069">Continue the Discussion <i class="fas fa-comments-alt"></i></a>          </div>