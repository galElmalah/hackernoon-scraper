<figure><img alt src="https://cdn-images-1.medium.com/max/1024/1*eHSqWhMf5Gt-jaczcdp30w.jpeg"></figure><p>One morning, as I was warming my breakfast in the office kitchen, a colleague of mine walked in and we started engaging in some small talk. I&#x2019;m going to call this colleague Freddie. Freddie had been at the company for a few of weeks, so naturally, I asked him how things had been going. What he went on to say has stuck with me since. He started with a sigh and spoke about how he had been having trouble understanding the codebase he had inherited on the particular project he was working&#xA0;on.</p><p>Freddie then spent a good deal of time telling me about how had become irritated and weary from staring at a behemoth of a function that made no sense. I asked him if he tried checking with one of his teammates who had been working on the software before him, to which he responded with a slight chuckle and said the following, &#x201C;(Teammate&#x2019;s name) had no clue either. He stared at it as intently as I did and simply said that he didn&#x2019;t write&#xA0;it.&#x201D;</p><p>I told myself two things after my conversation with Freddie. The first one was, &#x201C;Don&#x2019;t be that guy!&#x201D;. That is, don&#x2019;t be like the person who made Freddie suffer. The second was, &#x201C;Write better functions&#x201D;. That&#x2019;s the only way to not be like that guy. I&#x2019;m sure there are countless Freddie&#x2019;s out there who have to inherit, make sense of and refactor badly written functions on software projects. Well crafted software takes concern for the small units (or methods) such as functions at the micro level and not just the overall functionality at the macro&#xA0;level.</p><p>I&#x2019;ve written a lot bad functions in my short coding time, and so I became deliberate about improving in this particular area. Below are some guidelines and approaches that I&#x2019;ve learned (and am still learning) to apply from experienced professionals, colleagues, and other recommended sources.</p><p><strong>Understanding Functions</strong></p><p>Defining things is always a good place to start. Functions are programmed procedures. If you&#x2019;re looking for something more verbose than that, you&#x2019;ll have to go to Google. Software systems will comprise of functions to varying degrees. It may be that you&#x2019;re developing software with an Object Oriented design in which the functions will live inside the classes that make up the system, and those functions act on the state of the classes in which they live. Or maybe your system is a Function oriented design, in which the system is decomposed into a set of interacting functions acting on centralised state. Regardless of the approach, functions exist because we need to decompose our solution concept, and at a very low level of this decomposition, we find these small units that serve a specific&#xA0;purpose.</p><p><strong>Functions Should Be&#xA0;Small</strong></p><p>Keeping things small makes functions easier to read, understand, test and debug. I&#x2019;m not going to give you a magic number. Some experts would say not more than 15 lines, others would say not more than 25. It&#x2019;s probably something you&#x2019;ll have to decide within your team. The important thing is to remember the reasons for the principle of keeping functions small.</p><p><em>Readability</em>: A function will typically have a signature and a block code which is executed when the function is called or invoked. Having fewer lines of code in the function&#x2019;s block helps to easily read and get the gist of what the function is supposed to&#xA0;do.</p><p><em>Understandability</em>: Smaller functions help reduce the likelihood of deviating from the main purpose of a function. The more linear the concept or purpose of the function is, the more comprehensible it will&#xA0;be.</p><p><em>Testability</em>: Short methods have fewer variations which means they are easier to&#xA0;test</p><p>Here&#x2019;s an example of a function that is meant to check the validity of a bearer&#xA0;token:</p><iframe src width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5aa6462a1b56f007cecbfee7df1d87ed/href">https://medium.com/media/5aa6462a1b56f007cecbfee7df1d87ed/href</a></iframe><p><strong>Functions Should Be&#xA0;Clean</strong></p><p>It probably doesn&#x2019;t get more ambiguous than that. However, this isn&#x2019;t so much about code styles, indentations or variable name lengths. It&#x2019;s about understandability. Would Freddie be able to look at your function, figure out it&#x2019;s intent and be able to make modifications with losing a days worth of&#xA0;work?</p><p>The boils down to the measure of how maintainable your code is, and maintainable code forms a great deal of the backbone of maintainable software. I understand that are other attributes that would be used to define clean code that are subjective and that&#x2019;s something you and your team can decide&#xA0;on.</p><p><strong>Functions Should Be&#xA0;Simple</strong></p><p>Something my Tech Lead would often say to me is, &#x201C;If it (the function) requires a lot of effort, you stop and rethink your solution&#x201D;. In our field, effort shouldn&#x2019;t always be applauded, because more often than not, effort produces something complex.</p><blockquote>&#x201C;In software development, effort doesn&#x2019;t grow linearly with complexity&#x200A;&#x2014;&#x200A;it grows exponentially. Therefore, it is easier to manage two sets of four scenarios each than one with six.&#x201D;&#x200A;&#x2014;&#x200A;<a href="https://learning.oreilly.com/library/view/real-world-maintainable-software/9781492042853/">Abraham Mar&#xED;n-P&#xE9;rez</a></blockquote><p>If we can write functions based on a modularised solution, and reduce the paths of execution that the function has, it will be a lot easier to make sense of what they should be doing. When code isn&#x2019;t simply written, it&#x2019;s a lot harder to make sense of and these kinds of misunderstandings often lead to&#xA0;bugs.</p><p>Here&#x2019;s an example of a function that checks if a received argument is an array of&#xA0;strings:</p><iframe src width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4c27f93582eb6c008436b495b7b1aafa/href">https://medium.com/media/4c27f93582eb6c008436b495b7b1aafa/href</a></iframe><p><strong>Functions Should Have One Job (No Side&#xA0;Effects)</strong></p><p>Robert Martin put it best in Clean Code, &#x201C;Your function promises to do one thing&#x2026;&#x201D;, and therefore it should. Having side effects only makes our code less readable because of the variations in the code block that don&#x2019;t serve that one specific purpose. Our functions should be based on a <a href="https://www.geeksforgeeks.org/difference-between-deterministic-and-non-deterministic-algorithms/">deterministic algorithm</a>, given a certain input, it always returns the same&#xA0;output.</p><figure><img alt src="https://cdn-images-1.medium.com/max/268/1*PzJ0z1FYiD7RfKQDK9uqLA.gif"></figure><p>Take the following example, the function is meant to receive a particular date and return the week that the date occurs in the form of an array with date&#xA0;objects.</p><iframe src width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5863c8a090244a05a2cf2895ae229ac5/href">https://medium.com/media/5863c8a090244a05a2cf2895ae229ac5/href</a></iframe><p>It could be argued that the function generally has a single purpose. However, you may have noticed that there&#x2019;s a point at which we are generating the week based on two arguments, an object (<a href="https://momentjs.com/">Moment</a> object in this case) and the days of the week (i.e. Sunday, Monday, Tuesday, etc.). So we can actually create a new function from this one to simply things and make our methods more linear in their&#xA0;purpose.</p><p>When we split our function into two, we have the following:</p><iframe src width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0eb5dd6f2ea7b788e15a7ddd628b1d6c/href">https://medium.com/media/0eb5dd6f2ea7b788e15a7ddd628b1d6c/href</a></iframe><p>As a result, it is now easier for a random programmer to grasp the intent of our functions, make test cases for them and modify if necessary.</p><p><strong>That being&#xA0;said&#x2026;</strong></p><p>These guidelines are not the only ones to be followed, but they certainly lay a good enough foundation in helping us produce high quality code when we write our functions. Furthermore, writing good functions will take practice, deliberate refactoring, and another set of eyes (peer reviews). It might seem like extra work to produce this kind of code, but the returns are well with it. Edsger Dijkstra, a programming godfather, said the following,</p><blockquote>&#x201C;In programming, elegance is not a dispensable luxury but a quality that decides between success and failure.&#x201D;</blockquote><p>Don&#x2019;t be that guy, write better functions.</p><p>References:</p><p>Clean Code by Robert&#xA0;Martin</p><p><a href="https://www.oreilly.com/library/view/real-world-maintainable-software/9781492042853/">Real-World Maintainable Software</a></p>                <div class="archive-tags">                                        <a class="tag" href="https://hackernoon.com/tagged/programming">Programming</a>                                        <a class="tag" href="https://hackernoon.com/tagged/code-quality">Code Quality</a>                                        <a class="tag" href="https://hackernoon.com/tagged/software-engineering">Software Engineering</a>                                        <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                                        <a class="tag" href="https://hackernoon.com/tagged/functional-programming">Functional Programming</a>                  </div>                <div class="twitter-discussion">          <a target="_blank" href="https://twitter.com/search?q=https%3A%2F%2Fhackernoon.com%2Fdont-be-that-guy-write-better-functions-f5423aa01c1f">Continue the discussion <i class="fab fa-twitter"></i></a>        </div>