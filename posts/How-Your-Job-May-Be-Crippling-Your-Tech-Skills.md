<h4>A desire for simplistic on-boarding and fail-safe environments ease developers into a self-destructive comfort.</h4><p>Modern software applications are monstrous. Even small corporate products can be composed of layers upon layers of abstractions. Depending on which layer you work most closely with, there&#x2019;s a lot you could potentially be missing out&#xA0;on.</p><figure><img alt src="https://hackernoon.com/hn-images/0*H--dUV2oWVK5AHlx"><figcaption>Photo by <a href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral">Markus Spiske</a> on&#xA0;<a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><p>This post isn&#x2019;t about learning a new language or framework in your company&#x2019;s tech stack, nor is it about suggesting they use new, more modern, ones. This post is about ensuring mastery in whatever fraction of a stack you specialize in&#x200A;&#x2014;&#x200A;and knowing what to avoid specializing in. Below are several situations in which your job may be holding your career back, and how to escape&#xA0;them.</p><h3>Proprietary Programming Languages</h3><p>Some companies invest a lot of time and resources to produce their own internal languages. These languages are proprietary&#x200A;&#x2014;&#x200A;meaning no information about them can leave the company&#x2019;s walls. The risks of this should be&#xA0;obvious:</p><ul><li>You&#x2019;re unable to transfer these skills to another job, since no other company can use the technology. You may even be prohibited from discussing details about it during interviews and phone&#xA0;screens</li><li>There is an implicit &#x201C;sunk cost&#x201D; associated with mastering these languages.</li></ul><p>Any time you spend learning, developing, and potentially mastering, a proprietary language is time you could have spent learning something much more marketable, and more widely-used. You could have delved deeper into algorithms, open-source technologies, or the hottest new JavaScript framework.</p><p>The only real way to escape this trap is to leave and find another job. However, keep in mind that you can still progress your soft-skills and coding best practices while working in such an environment.</p><h3>Internal Implementations and Abstractions</h3><p>This situation is much more obscure, so allow me to draw upon two personal anecdotes.</p><p>At my first job, I was entrenched in SQL development designed to feed data into the company&#x2019;s main application. I was never exposed to said application, its APIs, documentation, or even its tech stack. It was the epitome of a &#x2018;black box&#x2019; so much so that we even referred to it as such. I left that job with a strong understanding of SQL, but lacked any front-end knowledge of the product, including how it interacted with my work. All of this was because <strong>I was comfortable</strong> being coddled by the company&#x2019;s attempts to segregate developer&#x2019;s tasks from each&#xA0;other.</p><p>More recently, I worked within the <a href="https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html">Apache MapReduce</a> framework every day for over a year. For those who don&#x2019;t know: A MapReduce Job has 3 main components: a Mapper, a Reducer, and a Runner. These components make up the core of any MapReduce Job, and I knew absolutely nothing about how to configure them directly. My team had written their own wrapping framework around MapReduce, and I was very familiar with this&#x2026;but not the underlying implementations. <strong>This is your real&#xA0;danger</strong>.</p><p>From the side of your employer&#x200A;&#x2014;&#x200A;this is a huge positive. More abstractions on top of convoluted frameworks means new developers can be on-boarded quicker, write code faster, and produce fewer bugs than if developing on top of the pure implementation. Teams should be encourage to reduce complexity and implement safeguards, wrappers, and ease of use scripts into their daily development lives. Here&#x2019;s the key though: Its your duty to understand the underlying implementation, and then gain appreciation for the abstractions you once held as a crutch. Its not your team&#x2019;s fault they did such a good job abstracting complexity&#x200A;&#x2014;&#x200A;it&#x2019;s yours for succumbing to the comfort your predecessors designed for&#xA0;you.</p><p>The perfect illustration of this concept is high school algebra. Almost every equation and concept you studied in class is now solvable with a quick <a href="https://www.wolframalpha.com/">Wolfram-Alpha</a> search, but that sure as shit wasn&#x2019;t allowed. Before using a calculator, you had to learn long-division; before accepting the quadratic formula, you had to discover it by c<a href="https://www.mathsisfun.com/algebra/quadratic-equation-derivation.html">ompleting the square on a quadratic function</a>.</p><figure><img alt src="https://hackernoon.com/hn-images/1*kMOXmVKPbgHzaVZA-29afA.jpeg"><figcaption>Proof of the quadratic formula</figcaption></figure><p>Just like algebra class: we first need to study the underlying solutions to equations we use, only after can we truly appreciate our abstractions. Failing to do this results in an apparent lack of what I call tech-confidence. Theres a clear difference between a developer who truly knows the frameworks they utilize&#x200A;&#x2014;&#x200A;and one who simply knows how to use them. Sure, you can survive, and even flourish, by only understanding whats on the surface, but you and I both know you&#x2019;re capable of more than&#xA0;that.</p><figure><img alt src="https://hackernoon.com/hn-images/1*nPgQ_Vpq0QH-l6fnkiWWdA.jpeg"><figcaption>Nobody wants just the&#xA0;tip&#x2026;</figcaption></figure><h3>Never Stop&#xA0;Learning</h3><p>The turning point in my career was when I switched gears&#xA0;from:</p><blockquote>I know enough to be <strong>effective</strong> in my current&#xA0;position</blockquote><p>To:</p><blockquote>I can be <strong>most effective</strong> in my current role, and in future roles, if I choose a specialization <strong>and</strong> <strong>master&#xA0;it</strong></blockquote><p>With this new mindset, I finally escaped a job that was locking me into a bleak future, became more connected to my daily development projects by actually understanding the technologies I utilized, and conveniently doubled my salary in the&#xA0;process.</p><p>Below are the steps you can (and should) take to reach engineering self-actualization:</p><h3>Choose a Specialization</h3><p>Specialized developers are far more marketable than those who generalize. In the past I mistakenly applied to dozens of &#x201C;Software Developer&#x201D; jobs by packing my resume with every language or framework I had ever touched, which to my demise included HTML/CSS. This got me nowhere, because while I was endeavoring to appear a &#x201C;Jack of all Trades&#x201D;, I instead presented myself as a &#x201C;Master of&#xA0;None&#x201D;.</p><p>You&#x2019;ll find that even when your specialization doesn&#x2019;t exactly match a position&#x2019;s hiring requirements, you&#x2019;ll still be considered due to your evident expertise and ability to digest complex technologies. In other words: those who specialize prove themselves more so than generalists, and said proof is much more apparent. Below are two examples of candidates skillsets I&#x2019;ve seen on&#xA0;resumes:</p><blockquote><strong>Tech Skills:</strong> Java, Ruby, SQL, Apache Hadoop (HDFS, MapReduce, Spark, Cassandra), Linux (zsh), Vim,&#xA0;Git</blockquote><blockquote><strong>Tech Skills:</strong> Java, Ruby, Python, Bash, SQL, C, C++, C#, HTML, CSS, Flask, Algorithms, Data Structures, SASS, JavaScript, CoffeeScript, Rails, PHP, AWS, S3, Redshift, Linux, Mac, Windows, Microsoft Office, Jira, Github, IntelliJ, Eclipse</blockquote><p>As an interviewer: the latter screams &#x201C;I probably know none of these, and just wrote down every technology I&#x2019;ve ever touched&#x201D;. They included Microsoft Office, Github (as in the website..not &#x2018;Git&#x2019; the tool), and the dreaded &#x201C;HTML/CSS&#x201D;.</p><p>The former appears much stronger: they imply a core competency and the subtle inclusion of vim and their shell preference suggest they&#x2019;re comfortable on the command-line. This candidate has a clear specialization, and a skillset I can more easily&#xA0;digest.</p><p>Surprise! Both of these candidates were me, and only one of the above approaches led to serious interviews, I&#x2019;ll let you guess which one. Also, don&#x2019;t put Microsoft Office on your tech resume, or any skill you can&#x2019;t backup&#x200A;&#x2014;&#x200A;trust&#xA0;me.</p><h3>Never Stop Reading&#x200A;&#x2014;&#x200A;Never Stop&#xA0;Doing</h3><p>The keys to your future have already been written down just waiting for you to pick them up, it&#x2019;s really that simple. Books hold all the knowledge you need to master your career, all you need is to actually read&#xA0;them.</p><p>Countless developers graduate and decide their job will teach them all they need to know. As we&#x2019;ve already shown, this an extremely dangerous comfort! By simply being proactive and continuing your education, you&#x2019;re already more prepared, more marketable, and will eventually become more knowledgable than all those who chose to lag behind. Guides, courses, books, documentation, open source projects, and APIs are all great sources of content to dive&#xA0;into.</p><p>Reading by itself is an amazing start, but isn&#x2019;t enough on its own. The key to developing your skills is to &#x2018;just do&#x2019;. It really doesn&#x2019;t matter what you decide to code, but you need to put your newfound skills to use to solidify them. Just finished a book on MapReduce? Thats great! Now get out there and write a MapReduce job on some famous<a href="https://www.ncdc.noaa.gov/cdo-web/datasets"> sample weather&#xA0;data</a>.</p><p>This industry is one that never stops improving, so neither should you&#x200A;&#x2014;&#x200A;lest you find yourself stuck in a cubicle, maintaining a legacy application built on a deprecated framework. If you only takeaway one thing from this post let it be&#xA0;this:</p><blockquote>The best investment in your future is to invest in&#xA0;yourself</blockquote>                <div class="archive-tags">                                        <a class="tag" href="https://hackernoon.com/tagged/coding">Coding</a>                                        <a class="tag" href="https://hackernoon.com/tagged/programming">Programming</a>                                        <a class="tag" href="https://hackernoon.com/tagged/software-engineering">Software Engineering</a>                                        <a class="tag" href="https://hackernoon.com/tagged/personal-development">Personal Development</a>                                        <a class="tag" href="https://hackernoon.com/tagged/software-development">Software Development</a>                  </div>                <div class="twitter-discussion">          <a target="_blank" href="https://twitter.com/search?q=https%3A%2F%2Fhackernoon.com%2Fhow-your-job-may-be-crippling-your-tech-skills-1b1b7a8ff3fd">Continue the discussion <i class="fab fa-twitter"></i></a>        </div>