<figure><img alt src="https://cdn-images-1.medium.com/max/1024/0*N017fpumKIZQOr8b"><figcaption>Photo by <a href="https://unsplash.com/@hojipago?utm_source=medium&amp;utm_medium=referral">EJ Yao</a> on&#xA0;<a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><p>Recently I&#x2019;ve been working on understanding more Javascript fundamentals and I took a look at hoisting. I thought that it was a pretty cool concept, so have written a blog post explaining it.</p><h3>What is hoisting?</h3><p>Hoisting is a process in the Javascript engine which does a pass through your code and allocates memory based on the presence of certain things. Hoisting is a way for us to understand how this&#xA0;works.</p><p>In the <a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/">Global Execution Context</a>, there are two stages, the creation stage, and the execution stage. The former provides the Global Object (e.g. &#x2018;Window&#x2019; in the browser), the this keyword, and hoisting. The latter is when we run our&#xA0;code.</p><p>When the Javascript engine does its pass through your code, it looks for function declarations (but not arrow functions, or function expressions), and variables (excluding let or const). These are then &#x2018;hoisted&#x2019; which allocates them space in&#xA0;memory.</p><h3>Partial Hoisting</h3><p>First up is partial hoisting. This applies to variables only. Functions are handled differently. So consider the code&#xA0;below:</p><iframe src width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9bbbe5b87308be20f623fda44d0eff54/href">https://medium.com/media/9bbbe5b87308be20f623fda44d0eff54/href</a></iframe><p>So on the first line we try and console.log our favouriteDrink variable. There&#x2019;s a problem here though - we haven&#x2019;t defined it yet. So really we should get a Reference Error right? Where is undefined coming&#xA0;from?</p><p>Well, when the Javascript engine passes through the code above, it sees that we have a var and realises that a variable is going to be defined. It doesn&#x2019;t care what the variable is, but it knows that some memory is going to be needed, so it allocates some in the heap so that it&#x2019;s ready when we need&#xA0;it.</p><p>This is why you then get &#x2018;undefined&#x2019; in the example above. You&#x2019;ve probably seen this when coding before right? Well it&#x2019;s just Javascript&#x2019;s placeholder. It won&#x2019;t break the script, but it knows that something will be allocated to our favouriteDrink variable.</p><p>Great, so how about a trickier example? Look at the code&#xA0;below:</p><iframe src width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7c3daa274a21c2b92e2235baa705b9a6/href">https://medium.com/media/7c3daa274a21c2b92e2235baa705b9a6/href</a></iframe><p>Ok, so we have two variables with the same name, but different values. How does Javascript handle this? It doesn&#x2019;t care. For the purposes of hoisting, the engine sees the first variable declaration and assigns it some space in the memory heap. It then sees a second declaration of the same variable, but the value of that variable isn&#x2019;t significant. The memory has already been assigned, so the engine simply ignores&#xA0;it.</p><p>When you run the code above, our second console.log statement predictably returns beer, as we&#x2019;re taking the latest declaration of the variable.</p><p>As a note, remember that the following won&#x2019;t&#xA0;work:</p><pre><code class="language-markup">const a = &apos;Foo&apos;; let b = &apos;Bar&apos;;</code></pre><p>Neither const not let get&#xA0;hoisted.</p><h3>Full Hoisting</h3><p>Function declarations (but not expressions, or arrow functions) are fully hoisted. This means that the function is allocated space in the memory heap, but instead of simply creating a placeholder like we saw in the previous section, the contents of that function are stored in memory. So for an&#xA0;example:</p><iframe src width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8f7b1c79757c7b8b3c0b91446f8974c6/href">https://medium.com/media/8f7b1c79757c7b8b3c0b91446f8974c6/href</a></iframe><p>As we can see, we call the function before we have actually written it. So what&#x2019;s going on here? Well, the contents of the function have been stored in memory, and so Javascript knows what you&#x2019;re looking for. Imagine that the function had actually been taken from where we have written it, and instead been placed at the top of the file. That&#x2019;s generally an easy (albeit simplistic) way to visualise hoisting. Instead, the memory is assigned into the memory&#xA0;heap.</p><p>So let&#x2019;s look at a more complex&#xA0;version:</p><iframe src width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ce1219f1b51f2bcf56709c70c0f5861a/href">https://medium.com/media/ce1219f1b51f2bcf56709c70c0f5861a/href</a></iframe><p>Do you understand why we get undefined in our first console.log and running in our second? Well, hoisting happens on every execution context. Any time you run a function in Javascript, a new execution context is created and we have to go through the creation and execution stages in the Global Execution Context&#xA0;again.</p><p>So when we call favouriteSport() we create a new execution context and hoisting happens. So in our first console.log we have undefined because the Javascript engine has created our placeholder. So in the execution stage, we call our function and a new execution context is created. Inside of the execution context, we only have access to the variable inside the function. The variable is hoisted and becomes undefined until we provide a value to it, in this case - &#x2018;running&#x2019;.</p><p>Then when we call console.log again, we have a value assigned to our variable and we get our correct output. Make&#xA0;sense?</p><p>Please note that the following won&#x2019;t&#xA0;work:</p><iframe src width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a71ab3b29c71083f07691f9fd0a238eb/href">https://medium.com/media/a71ab3b29c71083f07691f9fd0a238eb/href</a></iframe><p>This is because Javascript does not hoist function expressions, or arrow functions.</p><h3>Conclusion</h3><p>So that is a very quick introduction to hoisting. Hopefully you found this easy to follow and now understand the concept better. It&#x2019;s actually pretty&#xA0;simple.</p><p>Is hoisting a good thing though? Well, that depends. It&#x2019;s certainly quite a confusing topic, particularly for beginners and can make code less readable. On the other hand, it&#x2019;s a quirky feature of Javascript which allows for flexibility in how your code is&#xA0;written.</p><p>Personally I would avoid hoisting where I can in favour of more readable code. I tend to use const and let over var anyway and this stops me from (ab)using hoisting by default. I find that if you trigger a Reference Error then you need to look at your code structure and not rely on the internals of Javascript to hopefully figure it out for&#xA0;you.</p><p>If you enjoyed this, then I&#x2019;d recommend checking out Andrei Neagoie&#x2019;s <a href="https://www.udemy.com/advanced-javascript-concepts/">Advanced Javascript Course</a>&#x200A;&#x2014;&#x200A;I&#x2019;ve certainly found it very&#xA0;helpful!</p><p><em>Originally published at </em><a href="https://ruairidhwm.github.io/2019/03/19/javascript-hoisting.html"><em>ruairidhwm.github.io</em></a><em> on March 19,&#xA0;2019.</em></p>